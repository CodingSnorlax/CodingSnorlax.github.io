[{"title":"什麼是關注點分離","url":"/2021/12/22/%E4%BB%80%E9%BA%BC%E6%98%AF%E9%97%9C%E6%B3%A8%E9%BB%9E%E5%88%86%E9%9B%A2/","content":"為什麼網頁需要關注點分離？關注點分離能夠使網頁更方便開發與維護，拆解出的各個部分不僅可以獨立開發、方便日後維護，一處的修改也不會對其他部分連動影響，且各個部分都可重複使用。\n關注點分離概念網頁的關注點分離可視為四個部分的拆解，而當這些區塊拆解開後，開發者只需要花心力在處理資料集與資料處理控制。\n\nHTML 畫面\n資料集：網頁中的主要資料內容。\n資料處理控制：新增、修改、刪除 資料集 的各種行為。\n渲染方法：只執行單純渲染行為，不做資料處理。\n\n\n實例操作HTML 畫面&lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; id=&quot;inputByAdd&quot;&gt;&lt;button type=&quot;button&quot; id=&quot;buttonByAdd&quot;&gt;新增&lt;/button&gt;\n\n建立資料集const data = [  &#123;    id: 1,    furniture: &#x27;五斗櫃&#x27;  &#125;,  &#123;    id: 2,    furniture: &#x27;四人座沙發&#x27;  &#125;];// (1) 設定 data id 值let dataNum = data.length;\n\n資料處理控制這邊針對資料集內容的修改可分為新增、刪除函式：\n\naddItem(content)\nremoveItem(id)\n\n// (2) 設定增加一筆資料的函式    function addItem(content)&#123;      dataNum++;      data.push(&#123;        id: dataNum,        content      &#125;)      render()      &#125;        // (3) 設定刪除一筆資料的函式    function removeItem(id)&#123;      const index = data.findIndex((item) =&gt; item.id === id);      data.splice(index, 1);      render()    &#125;\n\n渲染畫面 (無資料處理)// (4) 綁定 DOM 元素    const dom = document.querySelector(&#x27;#app ul&#x27;)    const addBtn = document.querySelector(&#x27;#buttonByAdd&#x27;)    const addInput = document.querySelector(&#x27;#inputByAdd&#x27;)// (5) 渲染畫面    // 綁定監聽事件：增加資料    addBtn.addEventListener(&#x27;click&#x27;, function()&#123;      const inputValue = addInput.value;      addInput.value = &#x27;&#x27;;      addItem(inputValue)    &#125;)        function render()&#123;      let template = &#x27;&#x27;            data.forEach((item) =&gt; &#123;        template = template + `&lt;li&gt;$&#123;item.content&#125;          &lt;button type=&quot;button&quot; class=&quot;removeBtn&quot; data-id=&quot;$&#123;item.id&#125;&quot;&gt;刪除&lt;/button&gt;          &lt;/li&gt;`      &#125;)            dom.innerHTML = template      // 綁定監聽事件：刪除資料      const removeBtn = document.querySelectorAll(&#x27;.removeBtn&#x27;)      removeBtn.forEach(function(btn)&#123;        btn.addEventListener(&#x27;click&#x27;, function(e)&#123;          const itemID = Number(e.target.dataset.id);          removeItem(itemID)        &#125;)      &#125;)    &#125;        render()    addItem(&#x27;實木書桌&#x27;)    removeItem(2)\n\n\n","categories":["Vue","關注點分離"],"tags":["Vue"]},{"title":"陣列方法: filter","url":"/2021/12/22/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95-filter/","content":"filter 陣列使用時機\n對資料進行篩選，return 一個新的陣列。\nreturn 判斷式為 true 的資料。\n\n\n\n資料集const fruitData = [    &#123;        type: &#x27;apple&#x27;,        price: 30,        num: 3    &#125;,    &#123;        type: &#x27;mango&#x27;,        price: 60,        num: 5    &#125;,    &#123;        type: &#x27;guava&#x27;,        price: 25,        num: 10    &#125;,    &#123;        type: &#x27;tangerine&#x27;,        price: 15,        num: 7    &#125;]\n\n\n\nforEach 搭配 if 判斷式forEach 搭配 if 判斷式也可篩選陣列，與 filter 差異在不會 return 一個新陣列。\nconst newData = []fruitData.forEach(function(item)&#123;    if(item.price &gt;= 25)&#123;        newData.push(item)    &#125;&#125;)\n\n\n\n\nfilter 一般寫法const newData = fruitData.filter(function(item)&#123;    return item.price &gt;= 25 //return 整個 item    &#125;)\n\n\n\nfilter 箭頭函式// (1)const newData = fruitData.filter((item) =&gt; &#123;    return item.price &gt;= 25 //return 整個 item&#125;)// (2) 省略 return 及 &#123; &#125;const newData = fruitData.filter((item) =&gt; item.price &gt;= 25)\n\n\n\n參考資料\nJavaScript 陣列處理必學巧技\n關於 JavaScript 陣列 20 種操作的方法\n\n\n\n","categories":["JavaScript","陣列"],"tags":["JavaScript"]},{"title":"陣列方法: findIndex","url":"/2021/12/23/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95-findIndex/","content":"findIndex 陣列使用時機\n對資料進行篩選，return 一筆資料的 索引位置(數字)。\nreturn 判斷式為 true 的資料 索引位置(數字)。\n透過取得該筆資料的陣列索引，可抓出單一筆資料並進行修改。\n\n\n\n資料集const fruitData = [    &#123;        type: &#x27;apple&#x27;,        price: 30,        num: 3    &#125;,    &#123;        type: &#x27;mango&#x27;,        price: 60,        num: 5    &#125;,    &#123;        type: &#x27;guava&#x27;,        price: 25,        num: 10    &#125;,    &#123;        type: &#x27;tangerine&#x27;,        price: 15,        num: 7    &#125;]\n\n\n\nforEach 搭配 if 判斷式forEach 搭配 if 判斷式也可篩出指定的陣列索引，與 findIndex 差異在不會 return 陣列索引，必須要另外再宣告一個變數。\nlet dataIndex = 0;fruitData.forEach(function(item, index)&#123;    if(item.type === &#x27;tangerine&#x27;)&#123;        dataIndex = index;    &#125;&#125;)fruitData[dataIndex].type = &#x27;orange&#x27;\n\n\n\nfindIndex 一般寫法const dataIndex = fruitData.findIndex(function(item)&#123;          return item.type == &#x27;tangerine&#x27; //return 索引位置(數字)     &#125;)fruitData[dataIndex].type = &#x27;orange&#x27;\n\n\n\nfindIndex 箭頭函式// (1)const dataIndex = fruitData.findIndex((item) =&gt; &#123;    return item.type == &#x27;tangerine&#x27; //return 索引位置(數字)&#125;)fruitData[dataIndex].type = &#x27;orange&#x27;// (2) 省略 return 及 &#123; &#125;const dataIndex = fruitData.findIndex((item) =&gt; item.type == &#x27;tangerine&#x27;)fruitData[dataIndex].type = &#x27;orange&#x27;\n\n\n\n回傳結果&#123;    type: &#x27;orange&#x27;, // 修改成功!    num: 7,    price: 15&#125;\n\n\n\n參考資料\nJavaScript 陣列處理必學巧技\n\n\n\n","categories":["JavaScript","陣列"],"tags":["JavaScript"]},{"title":"陣列方法: forEach","url":"/2021/12/22/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95-forEach/","content":"forEach 陣列方法簡介\nforEach 會遍歷陣列中的每一筆資料。\nforEach 不可跳出迴圈，若一定要終止迴圈，就用 for。\n\n\n\n參數在 forEach 迴圈內，可帶入 3 個參數，分別為：item, index, array，其中前兩個最為常用。\n\n\n跑迴圈次數陣列有幾筆資料，迴圈就跑幾次，以 fruitData 為例，迴圈跑 4 次。\n\n\n資料集const fruitData = [    &#123;        type: &#x27;apple&#x27;,        price: 30,        num: 3    &#125;,    &#123;        type: &#x27;mango&#x27;,        price: 60,        num: 5    &#125;,    &#123;        type: &#x27;guava&#x27;,        price: 25,        num: 10    &#125;,    &#123;        type: &#x27;tangerine&#x27;,        price: 15,        num: 7    &#125;]fruitData.forEach(function(item, index, arr)&#123;    console.log(item); //顯示各個物件    console.log(index); //顯示 0, 1, 2, 3    console.log(arr); //顯示整個 fruitData 陣列&#125;)\n\n\n\n參考資料\nJavaScript 陣列處理必學巧技\n\n\n\n","categories":["JavaScript","陣列"],"tags":["JavaScript"]},{"title":"陣列方法: reduce","url":"/2021/12/23/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95-reduce/","content":"reduce 陣列使用時機\nreduce 可以用來 累加 數字，且直接 return 一個累加後的值。\nreduce 的參數與其他陣列方法不太一樣，特殊的地方在於它可自定義 初始值。\n若有設定初始值，則 accu 最初的值 = 初始值。\n若無設定初始值，則陣列也不得為空陣列，否則會報錯。\n\narr.reduce(function(accu, item, itemIndex, arr)&#123;&#125;, 初始值)\n\n\n\n資料集const fruitData = [    &#123;        type: &#x27;apple&#x27;,        price: 30,        num: 3    &#125;,    &#123;        type: &#x27;mango&#x27;,        price: 60,        num: 5    &#125;,    &#123;        type: &#x27;guava&#x27;,        price: 25,        num: 10    &#125;,    &#123;        type: &#x27;tangerine&#x27;,        price: 15,        num: 7    &#125;]\n\n\n\n\nforEach 寫法forEach 不會 return 任何結果，因此計算之前，要先宣告一個變數儲存累加的結果。\nlet totalPrice = 0;fruitData.forEach(function(item)&#123;    totalPrice += item.price * item.num&#125;)console.log(totalPrice);\n\n\n\nreduce 一般寫法要算出攤位上的所有水果賣掉，共價值多少錢? (用四種水果的價格*數量)\nconst totalPrice = fruitData.reduce(function(accu, item)&#123;        return accu += item.num * item.price&#125;, 0)console.log(totalPrice) //745\n\n\n\nreduce 箭頭函式寫法\n箭頭函式自帶 return，可省略不寫。\n刪除 return，一併刪除大括號 { }。\n\n(1)const totalPrice = fruitData.reduce((accu, item) =&gt;        accu += item.num * item.price, 0)(2)const totalPrice = fruitData.reduce((accu, item) =&gt; accu += item.num * item.price, 0)\n\n\n\n\n\n參考資料\nJavaScript 陣列處理必學巧技\n\n\n\n","categories":["JavaScript","陣列"],"tags":["JavaScript"]},{"title":"陣列方法: sort","url":"/2021/12/23/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95-sort/","content":"sort 陣列使用時機sort() 可以接受帶入 函式參數，透過這個函式參數來設定 sort() 的排序。\n\n\n字串排序預設是根據字串的 Unicode 編碼位置而定。\narr = [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;k&#x27;]const newNumArr = arr.sort() \n\n\n\n\n數字排序假設有一個陣列，裡面有五個數字，希望透過陣列整理出 大到小 排序，透過函式，任選 a, b 兩個數字相減：\n\n若 a - b &gt; 0 則 a 的順序在 b 之前\n若 a - b &lt; 0 則 b 的順序在 a 之前\n若 a - b = 0 則 a, b 不動\n\narr = [33, 11, 45, 92, 11]function compareNum (a, b)&#123;    return b - a // 由大到小    return a - b // 由小到大&#125;const newNumArr = arr.sort(compareNum) //在 sort() 代入函式\n\n\n\n資料集const fruitData = [    &#123;        type: &#x27;apple&#x27;,        price: 30,        num: 3    &#125;,    &#123;        type: &#x27;mango&#x27;,        price: 60,        num: 5    &#125;,    &#123;        type: &#x27;guava&#x27;,        price: 25,        num: 10    &#125;,    &#123;        type: &#x27;tangerine&#x27;,        price: 15,        num: 7    &#125;]\n\n\n\nsort 箭頭函式// (1) 取得價格 由高到低 的排序const sortPriceData = fruitData.sort((a, b) =&gt; &#123;    return b.price - a.price&#125;)// (2) 取得數量 由多到少 的排序const sortNumData = fruitData.sort((a, b) =&gt; &#123;    return b.num - a.num&#125;)\n\n\n\n參考資料\nJavaScript 陣列處理必學巧技\nJavaScript 陣列排序 sort\n\n\n\n","categories":["JavaScript","陣列"],"tags":["JavaScript"]},{"title":"陣列方法: map","url":"/2021/12/22/%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95-map/","content":"map 陣列使用時機\nmap 與 forEach 很相似，都會遍歷陣列內的每一筆資料。\nmap 會 return 一筆新的陣列資料，適用於對陣列資料逐筆做修改時。\n\n備註 forEach 不會 return 一筆新的陣列資料。\n\n\n資料集const fruitData = [    &#123;        type: &#x27;apple&#x27;,        price: 30,        num: 3    &#125;,    &#123;        type: &#x27;mango&#x27;,        price: 60,        num: 5    &#125;,    &#123;        type: &#x27;guava&#x27;,        price: 25,        num: 10    &#125;,    &#123;        type: &#x27;tangerine&#x27;,        price: 15,        num: 7    &#125;]\n\n\n\nmap 一般寫法const newData = fruitData.map(function(item)&#123;    return &#123;        // 展開 item 值，刪去 &#123;&#125;         ...item,        newPrice: item.price * 0.6,            &#125;&#125;)\n\n\n\nmap 箭頭函式寫法\n箭頭函式自帶 return，可省略不寫。\n刪除 return，大括號 { } 也要一併刪除。\n外圍補上 ( )\n\nconst newData = fruitData.map((item) =&gt; (&#123;        ...item,        newPrice: item.price * 0.6,&#125;))\n\n\n\n回傳結果&#123;    type: &#x27;tangerine&#x27;,    num: 7,    price: 15,    newPrice: 9  // 新增成功!&#125;\n\n\n\nmap 搭配 join由於 map 方法回傳的是一整筆新的陣列資料，渲染到畫面上會看到各筆資料之間，是用逗號區隔開的，\n\n要刪除逗號，我們可透過 join(‘’) 空字串把逗號替代掉。\n\nconst htmlTemplate = fruitData.map(function(item)&#123;    return `&lt;li&gt;品項：$&#123;item.type&#125;，價格：$&#123;item.price&#125;&lt;/li&gt;`&#125;)const wrap = document.querySelector(&#x27;.wrap&#x27;)wrap.innerHTML = htmlTemplate.join(&#x27;&#x27;)\n\n\n\n參考資料\nJavaScript 陣列處理必學巧技\n關於 JavaScript 陣列 20 種操作的方法\n\n\n\n","categories":["JavaScript","陣列"],"tags":["JavaScript"]},{"title":"DOM API(一)：querySelector、querySelectorAll","url":"/2021/12/17/2021-12-DOM-API-%E4%B8%80/","content":"在寫 JavaScript 的時候，要綁定 DOM 一定會頻繁用到 querySelector 和 querySelectorAll，因此這篇要來紀錄一下這兩者的用法，以下也搭配 DOM 結構的示意圖。\n\n\n\nquerySelector (選取 1 個 / 第 1 個 DOM)只會選取一個 id 或 class，可用來綁定單一的 id 或 class，且當有多個同名的 class 時，也只會抓取其中符合條件的第一個 class：\nconst name = document.querySelector(&#x27;.js-name&#x27;);orconst name = document.querySelector(&#x27;#js-name&#x27;);\n\n\n\n\nquerySelectorAll (選取多個標籤組成 nodelist)如它的名稱所示，既然是 querySelectorAll()，根據傳入的 class 或屬性名稱，它就可以用來一次同時綁定多個同名 class 或屬性，且由於一次打包很多個 tag，它將會自動幫開發者組成一個 nodelist，用法範例：\n&lt;ul class=&quot;js-customer-list&quot;&gt;  &lt;li class=&quot;js-customer-item&quot;&gt;customer1&lt;/li&gt;  &lt;li class=&quot;js-customer-item&quot;&gt;customer2&lt;/li&gt;  &lt;li class=&quot;js-customer-item&quot;&gt;customer3&lt;/li&gt;&lt;/ul&gt;const customerList = document.querySelectorAll(&#x27;.js-customer-item&#x27;)\n\n\n\n\n\nnodelist 的順序性又因為 querySelectorAll 會組成一個 nodelist，而 nodelist 還具備陣列序列性的特質，因此也可以拆解成這樣來看：\nconsole.log(customerList[0]) console.log(customerList[1]) console.log(customerList[2])\n\n我們會得到這樣一個回傳的結果：\n\n\nnodelist 跟 li 對應的情形：\ncustomerList[0] 對應 &lt;li class=&quot;js-customer-item&quot;&gt;customer1&lt;/li&gt;customerList[1] 對應 &lt;li class=&quot;js-customer-item&quot;&gt;customer2&lt;/li&gt;customerList[2] 對應 &lt;li class=&quot;js-customer-item&quot;&gt;customer3&lt;/li&gt;\n\n\n用 nodelist 跑 forEach由於 nodelist 具備陣列的特性，當我們要一次同時改變許多個 tag，就可以用 forEach 迴圈來帶入這個陣列，進行一次修改全部的文字，如同剛剛的例子中，customerList (nodelist)，又可以繼續寫成：\n// 用陣列跑 forEachcustomerList.forEach(function(item)&#123;item.textContent = &#x27;customer does not exist&#x27;&#125;)// 此時，customer1, customer2, customer3 // 都會一起被改為 &#x27;customer does not exist&#x27;\n\n畫面將會被渲染如下：\n\n\n小結\nquerySelector：選取單一個元素。\nquerySelectorAll：選取多個元素。\n\n備註 同時還可以利用 querySelectorAll 組成 nodelist 的特性，來串接或修改資料，是很好用的一個功能。備註 nodelist 遇到有一些陣列方法不能使用，可以先把它轉成陣列，方法可參考 NodeList 與 Array 差異\n除了 querySelector、 querySelectorAll，另外還有 getElementById、getElementsByClassName 及 getElementsByTagName，將分別會記錄在選取 DOM 的方法(二)：回傳 HTMLCollection 物件這一篇當中。\n\n\n\n參考資料JavaScript DOM 查找元素 (DOM Traversing)Day03-深入理解網頁架構：DOM\n","categories":["JavaScript","選取器","DOM"],"tags":["JavaScript"]},{"title":"函式及箭頭函式","url":"/2021/12/24/%E5%87%BD%E5%BC%8F%E5%8F%8A%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F/","content":"函式陳述式函式陳述式在被宣告之前，就可以呼叫，寫法如下：\naddNum(1, 3) // okfunction addNum(a, b)&#123;        return a + b&#125;addNum(1, 3) // ok\n\n\n\n函式表達式函式表達式必須要在被宣告之後，才能呼叫，概念很像用 let, const 宣告的變數，也是要在被宣告後才能拿來用，寫法如下：\naddNum(1, 3) // 無法呼叫函式const addNum = function(a, b)&#123;        return a + b&#125;addNum(1, 3) // ok\n\n\n\n箭頭函式基本寫法箭頭函式寫法很接近函式表達式，只是 function 取代為 =&gt;\nconst addNum = (a, b) =&gt; &#123;        return a + b&#125;\n\n\n\n\n箭頭函式簡寫\nreturn 和大括號 { } 都可同步省略\n參數只有 1 個：可省略括號 ()\n沒有參數：至少要保留空括號 ()\n\n// (1)const addNum = (a) =&gt; a + a// (2)const addNum = a =&gt; a + a// (3)const addNum = () =&gt; 3 + 1\n\n\n\n","categories":["JavaScript","函式"],"tags":["JavaScript"]},{"title":"JS 中的傳值與傳址 (傳值篇)","url":"/2021/12/16/2021-12-JS-%E4%B8%AD%E7%9A%84%E5%82%B3%E5%80%BC%E8%88%87%E5%82%B3%E5%9D%80-%E5%82%B3%E5%80%BC%E7%AF%87/","content":"理解傳值和傳址最重要的三大關鍵\n必須先能分清楚「值」有分物件型別、原始型別\n變數在賦予值的時候，電腦記憶體空間是如何運作的\n有沒有進行「重新賦予值」這個動作\n\n基本上掌握這三點，那麽這個問題大概就先理清了一大半。所以，在要回答這個問題之前，是不是應該先問，什麼是值？\n什麼是「值」(Value)？先前在分辨 null 與 undefined 的差異這篇文章內，已討論過何謂「值」。所謂的「值」，就是在變數裡存進去的一筆資料，而這資料又分為物件型別與原始型別，可參考以下示意圖。\n\n\n如何運用「值」？舉例來說，今天有一個人名叫 Karen，他說他目前最喜歡的歌手叫做 Bruno Major，這一筆資料的值是一個人名，型別是字串。於是，Karen 最喜歡的歌手是 Bruno Major 這一筆資料，就儲存在 karenFavoriteSinger 這個變數裡了：\nlet karenFavoriteSinger = &#x27;Bruno Major&#x27;;\n\n什麼是「傳值」？此時，又來了一個 Karen 的同學 Yang，Yang 說好巧啊，他最喜歡的歌手也是 Bruno Major！所以他們兩個都很喜歡同一個歌手，於是可以這樣寫：\nlet yangFavoriteSinger = karenFavoriteSinger; //傳值 console.log(yangFavoriteSinger); // 回傳 Bruno Major\n\n又過了幾天，Karen 突然在 Watermelon Music 聽到了一首超棒的歌，噢，結果他很興高采烈地跟 Yang 分享這件事，他對天空大聲高喊說，他發現突然已經沒那麼喜歡 Bruno Major 了，現在他最喜歡的歌手是 Robbie Williams，於是可以這樣寫：\nkarenFavoriteSinger = &#x27;Robbie Williams&#x27;;\n\n現在，讓我們再度回過頭檢視 karenFavoriteSinger 和 yangFavoriteSinger 這兩個變數吧！\nconsole.log(karenFavoriteSinger); //回傳 Robbie Williams console.log(yangFavoriteSinger); // 仍然回傳 Bruno Major\n\n所以「傳值」這件事，其實可以理解為，Karen 和 Yang 曾經有過共同喜歡的歌手，但後來雖然 Karen 變了，他喜歡的跟 Yang 不同了，但是，Yang 是個有主見的人，他並不需要跟著一起改變啊！\n然而，這個現象背後的原理是：當變數每一次被賦予一個新的值，電腦都會開一個記憶體來儲存這個值，並重新將變數指向這個記憶體。\n兩步驟拆解「傳值」：\n電腦「複製」一個完完全全相同的值\n電腦同時新開一個記憶體空間儲存這個值，並把變數 yangFavoriteSinger 指向到這個值過去，最後，值都是儲存在各自獨立的記憶體空間。\n\n既然傳值後，值都是儲存在各自獨立的記憶體空間，那麼當變數重新賦予一個新的值，自然也會再依循剛剛的兩個步驟再走一次。\n\n\n小結：傳值的兩個重點\n傳值所指的「值」都是屬於原始資料型別 (Primitive Type)。\n傳值有一個很關鍵的重點是「複製」，複製後在記憶體空間中，兩個變數的值都是獨立存在不同的記憶體之中，因此，就算其中一方突然改變心意，各自都還是獨立個體，並不互相影響。\n\n","categories":["JavaScript","資料型別","變數與記憶體","原始型別"],"tags":["JavaScript"]},{"title":"來寫個 callback function","url":"/2021/12/25/%E4%BE%86%E5%AF%AB%E4%B8%80%E5%80%8B-callback-function/","content":"同步與非同步在 JS 的程式執行中，有分兩種模式：\n\n同步執行\n非同步執行\n\n\n\n同步執行一般來說，程式指令會按照由上至下的先後順序，第一個完成後，才接著執行第二個，依此類推。\n\n\n非同步執行非同步執行的程式碼，可以想像是，它會先在另一個區塊等待，等到被調用的時候，才執行。\n\n\n運行概念若按照同步執行的概念，假如有一個需要花較長時間才會完成的任務 A-1，當 A-1 跑完，才會跑 A-2，在同步執行的概念下，就要等到任務 A-2 完成，再接著執行任務 B、任務 C，似乎是很不聰明的做法？\n再看看非同步執行怎麼做：\n\n讓 A-1 持續工作\n讓 A-2 到 callback queue 等待\nA-1 持續工作的同時，任務 B、任務 C 繼續跑下去\n\n\n\n\n什麼是 callback function如前所述，callback function 屬於 非同步執行 的函式，因此在剛剛的案例中，callback function 就是 任務 A-2，會先在 callback queue 裡等待，回頭再被召喚的函式。\n另外，像綁定監聽事件的函式，也是一種 callback function，函式先預備在一旁，等事件發生 (ex: 被點擊)，才觸發執行。\n\n\n使用時機與方法\ncallback function 適用於各種需要對第三方服務發出的請求，因為等待資料回傳的時間難以掌握。\n\ncallback function 不會直接被執行，一定會是被當作一個 參數，傳到另一個函式內。\n\n\n\n\n實例一// 先宣告 greeting 函式 (然後就先擺著 = callback fn)function greeting(obj) &#123;  alert(&#x27;Hello &#x27; + obj.name);&#125;// greeting 函式調用的參數 (一個物件)let obj = &#123;  name: &#x27;Stranger&#x27;&#125;// 主要跑 callback fn 的函式function runCallBackFn(greeting, obj)&#123;  greeting(obj)&#125;runCallBackFn(greeting, obj)\n\n\n\n實例二\n  See the Pen \n  12/30 callback function by Karen Huang (@Coding_Snorlax)\n  on CodePen.\n\n","categories":["JavaScript","函式"],"tags":["JavaScript"]},{"title":"JS 中的傳值與傳址 (傳址篇)","url":"/2021/12/16/2021-12-JS-%E4%B8%AD%E7%9A%84%E5%82%B3%E5%80%BC%E8%88%87%E5%82%B3%E5%9D%80-%E5%82%B3%E5%9D%80%E7%AF%87/","content":"什麼是傳值？先前在傳值篇解釋過，在變數宣告並賦予值的過程中，變數是指向各個獨立的值，而這個值若是屬於「原始型別」，每一筆都將儲存在獨立的記憶體內，因此傳值的動作，可以理解為：變數指向的是另一份「複製」後的單獨記憶體。\n什麼是傳址？傳址是兩個變數共同指向同一個值，且這邊的值是屬於「物件型別」（它可能是物件、陣列或函式），因為傳址沒有複製值，當然不會有新的位址，可是兩個變數都指向同一筆資料，而這筆資料被儲存在某一個地點，並且有一個「位址 (address) 」。\nlet fruit1 = [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27; ] let fruit2 = fruit1; // 傳址 console.log(fruit2); // 回傳 [&#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;]\n\n傳址類似於 fruit 1 寫一張紙條給 fruit2，告訴它：「當你之後要找這筆陣列資料的時候，去紙條上這個地址就會找到。」\n\n\n傳址：兩個位址連動改變的現象既然 fruit1 與 fruit2 共用同一個陣列位址，當透過 fruit2 來刪減陣列內的資料會發現，在 fruit2 刪除陣列中的第一筆資料 orange，從 fruit1 查詢發現 orange 也一起不見了。\ndelete fruit2[0]; //刪除陣列中的第一筆資料 console.log(fruit1);\n\n\n\n▲ console.log(fruit1); 的結果\n傳址：重新賦予值假如對 fruit2 重新賦予值，fruit1 和 fruit2 各自會有什麼結果呢？根據回傳結果，可以得知，當對 fruit2 重新賦予值，fruit2 的值改變了，但 fruit1 仍然不受影響。\nlet fruit1 = [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27; ] let fruit2 = fruit1; // 傳址console.log(fruit2); // 回傳 [&#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;] fruit2 = [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;, &#x27;durian&#x27;] // 對 fruit2 重新賦予值 console.log(fruit2); // 回傳 [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;, &#x27;durian&#x27;] console.log(fruit1); // 回傳 [&#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;]\n\n這可以理解為，當對變數重新賦予值的時候，電腦就會再開一個新的記憶體空間來儲存這個值，當有新的空間、就有新的位址，那麼兩個變數這時就各自指向獨立的值，不再互相影響了。\n\n\n再看一個更進階的例子：當我現在需要把物件的某一個屬性的值取出，因此我另外再宣告一個新的變數 stationary 儲存這個值，同時最後我用 console.log 驗證一下變數是否有成功代入物件。\nlet myPencilCase = &#123;    &quot;color&quot;: &quot;brown&quot;,    &quot;contents&quot;: [&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;],&#125;let stationary = &quot;contents&quot;;console.log(myPencilCase[&quot;contents&quot;])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;](4)console.log(myPencilCase[stationary])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;](4)//代表變數已經成功抓到我要的值\n\n經過宣告 stationary 這個新的變數，自此之後，只要一修改 “contents” 屬性的陣列資料，這兩個地方的資料都會同步串聯了，例如：這邊用push()來新增一筆陣列資料。\nmyPencilCase[&quot;contents&quot;].push(&#x27;eraser&#x27;); //新增一筆陣列資料console.log(myPencilCase[&quot;contents&quot;])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;, &#x27;eraser&#x27;](5)console.log(myPencilCase[stationary])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;, &#x27;eraser&#x27;](5)\n\n但唯一做一個動作，就會斷掉兩者的牽連，那就是：重新對變數 stationary 賦予值。\nlet myPencilCase = &#123;    &quot;color&quot;: &quot;brown&quot;,    &quot;contents&quot;: [&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;]&#125;let stationary = &quot;contents&quot;;myPencilCase[stationary] = [666]stationary = [&#x27;marker&#x27;]; //重新對變數 stationary 賦予值。console.log(myPencilCase[&quot;contents&quot;]) //回傳 [666]console.log(myPencilCase[stationary]) // 回傳 undefined\n\n這邊的 myPencilCase[“contents”] 之所以會回傳 [666]，是因為 stationary 重新賦予值之前，透過這個變數 stationary 已經修改了“contents”陣列的資料，因此最終陣列資料停留在[666]。\n但後面將 stationary 重新賦予值，因此最後一行的 console.log 已無法透過 stationary 這個變數在 myPencilCase 這個物件內讀取資料了，故回傳 undefined。\n\n\n\n小結：傳址的三個重點\n傳址指的是當超過一個以上的變數要存取同一筆物件型別的值(物件、陣列或函式)。\n傳址可視為有一個以上的變數都指向同一個位址、取用同一筆物件型別的值，因此透過任一個變數去修改值，所有的變數的值都會連動一起改變。\n傳址後的兩個變數 fruit1、fruit2，雖然都會到同一個位址去存取一筆物件型別的資料，但假如對其中任一的變數 fruit1 再重新賦予一個值，此時電腦將另新開一個記憶體空間來存放這一筆資料，這時的 fruit1 與 fruit2 就各自指向不同的記憶體空間、資料也不再互相連動了。\n\n\n\n\n總結傳值 複製一筆值、產生獨立的記憶體空間來儲存資料，因此假如後續再對任一變數重新賦予值，兩者之間也不會產生影響。\n傳址 變數 a 複製了一個「位址」到變數 b 那邊去，所以兩個變數共同指向的仍是同一筆值，因此若透過任一個變數來修改這個值，兩者都會產生連動的改變。\n傳址又重新對其中一個變數賦予值 對變數重新賦予值會產生一個新的記憶體空間，又會回到很像傳值的時候，這時兩個變數裡面的資料內容並不相同。而這邊很關鍵的重點就是在於有了「重新賦予值」的動作，產生一個新的記憶體空間來儲存資料，導致 fruit1 與 fruit2 兩個變數日後不再互相影響。\n\n\n\n表格：重點回顧\n\n\n\n產生新記憶體空間\n產生新位址\n修改其中一個變數是否影響其他變數\n對其中一個變數重新賦予值是否還會影響其他變數\n\n\n\n傳值\nＶ\nＶ\nＸ\nＸ\n\n\n傳址\nＸ\nＸ\nＶ\nＸ\n\n\n\n\n\n\n參考資料\n你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 — — Pass by value, or Pass by reference？\nby reference (傳參考)、by value(傳值)的差別\nJavascript pass by reference or value\nHow to get a grip on reference vs value in JavaScript\n深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？\nJS 變數傳遞探討：pass by value 、 pass by reference 還是 pass by sharing？\n\n","categories":["JavaScript","資料型別","物件型別","變數與記憶體"],"tags":["JavaScript"]},{"title":"JS 物件(object) 的基礎觀念","url":"/2021/12/16/2021-12-JS-%E7%89%A9%E4%BB%B6-object-%E7%9A%84%E5%9F%BA%E7%A4%8E%E8%A7%80%E5%BF%B5/","content":"在開始看物件取值之前，再看一看物件的基本定義吧！\n物件的結構屬性(key) ：用來取得資料的「位置」。值(value) ：有不同型別。\n在物件內，沒有順序性，只有屬性名稱與值。\n\n\n物件的功能物件是 JavaScript 的物件型別之一，理解它的方法就跟在認識真實世界中的實體物件一樣，JS 的物件內會有很多屬性，而屬性可以是一個原始型別的值、物件或陣列，這些資料可以構成一項物品的詳細資訊。\n重點中的重點：物件主要在記述詳細資訊\n假設有一個筆袋，這是它的資訊：\n一個 Kokuyo 的黑色筆袋2020 年出廠材質是棉布非手工製造內容物：一枝尺、一枝鉛筆、一枝原子筆，及一個橡皮擦售價：原價 990 元，使用會員卡打折後為 891 元\n\n\n宣告物件現在就來用上面的文字敘述，宣告一個物件。\nlet pencilCase = &#123;      &quot;brand&quot;: &quot;Kokuyo&quot;,      &quot;year&quot;: 2020,      &quot;color&quot;: &quot;black&quot;,      &quot;material&quot;: &quot;cotton&quot;,      &quot;isHandmade&quot;: false,      &quot;contents&quot;: [&#x27;ruler&#x27;, &#x27;pencil&#x27;, &#x27;pen&#x27;, &#x27;eraser&#x27;],      &quot;01_price&quot;: 990,      &quot;02_price&quot;: 891 &#125;\n\n\n\n\n物件取值 (造訪資料)let product = &#123;//    屬性   值(value)    name: &quot;King Size Bed&quot;,    price: 3000,    color: &#x27;white&#x27;,&#125;console.log(personal.name) // &quot;King Size Bed&quot;console.log(personal.price) // 3000\n\n備註 這邊介紹的是用點取值，另外也還有用 [] 取值的方式。\n\n\n新增物件的屬性let product = &#123;//    屬性   值(value)    name: &quot;King Size Bed&quot;,    price: 3000,    color: &#x27;white&#x27;,&#125;product.id = &#x27;xiw9249204sp&#x27;console.log(product);// 回傳 &#123;name: &quot;King Size Bed&quot;, price: 3000, color: &#x27;white&#x27;, id: &#x27;xiw9249204sp&#x27;&#125;\n\n新增物件的屬性 &amp; 修改物件屬性內的值 :看起來都是用一樣的方法，但概念上有點不同。\n\n一個是新增一個全新的屬性到物件內\n一個是修改一個物件原有屬性的值\n\n\n\n重新賦予物件屬性的值let personal = &#123;//    屬性   值(value)    name: &quot;Karen&quot;,    money: 3000,    color: &#x27;white&#x27;,    pc: &quot;Mac M1 Max&quot;&#125;//語意：花了3000元買電腦personal.money -= 3000;//語意：增加購買條件 Mac M1 Max Ram36GB版personal.pc += &quot;Ram36GB版&quot;\n\n\n\n刪除物件的屬性let personal = &#123;//    屬性   值(value)    name: &quot;Karen&quot;,    money: 3000,    color: &#x27;white&#x27;,    pc: &quot;Mac M1 Max&quot;&#125;//語意：刪除 personal 物件的 pc 屬性delete personal.pc;delete personal[&quot;pc&quot;];","categories":["JavaScript","物件型別"],"tags":["JavaScript"]},{"title":"什麼是 CORS？","url":"/2021/12/20/2021-12-2021-12-CORS/","content":"CORS 概述跨網域資源共享，全名 Cross-Origin Resource Sharing，假如伺服器同意跨域分享資源，就要同意來自不同網域的 HTTP 發出的請求，並一一對這些請求作出回應，而這些回應最終會回到瀏覽器。\nCORS 設定的位置會是在伺服器端的 response headers，此時瀏覽器會在 response headers 檢查伺服器的回應，需要在這邊確認有開啟 Access-Control-Allow-Origin: *。\nCORS 應用案例 ：\n\n利用 &lt;img&gt; src 載入的圖片\n外部載入的 CDN (例如：google fonts, font-awsome…)\n\n\n\n確認 CORS 在伺服器是否開啟\n確認 response headers 有開啟 Access-Control-Allow-Origin: *備註 此處 * 是萬用字元，允許任何來源存取資源。\n\n假設在同一個網域內，JSON 資料可以互相傳送，就無資安疑慮；但問題就是，不同網域 所發出的 JSON 資料請求，需要確認該筆資料存在的伺服器是否有開放 CORS，若有開放 CORS，才支援跨網域請求。(不過實際上仍會遇到未開啟CORS，但仍能請求的例外情形)\n預檢請求 (preflight request)CORS 將請求分為 預檢請求 與 簡單請求，在瀏覽器發出簡單請求前 (post, put… 等會包含使用者身份驗證的請求)，瀏覽器會先發出預檢請求，這個動作主要是先確認伺服器有接受跨域請求，才會進行下一步執行開發者指定的請求(簡單請求)。\n而當預檢請求通過後，HTTP 狀態碼會是 200，但若是最後被 CORS 擋下，會因為伺服器未實際回傳資料，XHR status 為 0。\n備註 HTTP status 200 僅是代表伺服器成功回應。\n\n\ntest-cors 查詢利用 test-cors 觀察 JSON 資料或 API 是否能介接。\n\nXHR status: 200 代表可以介接，有撈到資料。\nXHR status: 0 代表 不可跨網域 請求。\n\n\n\n實際案例\n全球運動場館資訊網 =&gt; 可透過 axios 在瀏覽器讀取XHR status: 200HTTP Status Code: 200沒有 Access-Control-Allow-Origin: *\n\nUnsplashXHR status: 401HTTP Status Code: 401 (伺服器收到未經身份驗證的請求)有 Response Headers =&gt; access-control-allow-origin: *\n\n里長資訊網XHR status: 0HTTP Status Code: 200沒有 Access-Control-Allow-Origin: *\n\n中央氣象局開放資料平臺 =&gt; 可透過 axios 在瀏覽器讀取XHR status: 200HTTP Status Code: 200有 Response Headers =&gt; Access-Control-Allow-Origin: *\n\n旅遊人數明細表XHR status: 0HTTP Status Code: 200沒有 Access-Control-Allow-Origin: *\n\n\n\n\n總結實際上判斷 JSON 資料能否用 JS 讀取，還是要以 XHR status 200 做判斷！XHR、HTTP status 200 皆屬於從伺服器回傳成功的資訊給使用者/開發者，而只要有 XHR 200，就算沒有標註 Access-Control-Allow-Origin: * 也沒有關係。\n\n\n參考資料\n輕鬆理解 Ajax 與跨來源請求\n網頁開發人員應了解的 HTTP 狀態碼\n\n\n\n","categories":["JavaScript","AJAX"],"tags":["JavaScript"]},{"title":"AJAX 取資料及 XMLHttpRequest","url":"/2021/12/20/2021-12-2021-12-AJAX/","content":"什麼是 AJAX?全名為 Asynchronous JavaScript and XML，最核心的語法部分是 XMLHttpRequest。\n在頁面上即便沒有重新整理網頁，透過 AJAX 也能用瀏覽器撈取遠端資料庫，並即時同步回傳後端資料庫的資料，使得網頁能即時更動、回應。\n\n\n取得 AJAX 資料的方法發展到現今已有三種方法都可發請求，取得 AJAX 資料：\n\nXMLHttpRequest \nfetch\naxios (操作底層原理是 XMLHttpRequest)\n\n\n\nAJAX 非同步特性非同步特性不會等到資料回傳，而是在資料尚未回傳前，持續讓程式碼繼續往下跑完，對使用者來說，等待資料的過程，畫面上還是有其他資訊可以觀看或有介面可以操作，等伺服器回應後，就得到回傳的資料。\n\n\n\nAJAX 可發出的請求格式\nget (讀取)\npost (傳送資料到伺服器)\npatch (修改)\nput (修改)\ndelete (刪除)\n\n\n\n\nXMLHttpRequest 原生語法透過以下第 2 行程式碼的宣告，產生一包新的 XMLHttpRequest 物件，能開始透過瀏覽器和其他伺服器要資料。\nlet xhr = new XMLHttpRequest()        // 格式、 url 、 是否同步xhr.open(&#x27;get&#x27;, &#x27;網址&#x27;, true)xhr.send()\n\n\n\nreadyState 請求狀態透過 readyState 查詢目前狀態 (再 call 一次 xhr 可觀察到 readyState)：\n\nreadyState: 0 =&gt; 已成功建立 XMLHttpRequest 物件，但尚未撈取資料。\nreadyState: 1 =&gt; 用了 xhr.open()，但尚未送出。\nreadyState: 2 =&gt; 已發出 xhr.send()。\nreadyState: 3 =&gt; loading\nreadyState: 4 =&gt; 已成功撈取資料。\n\n\n\n\nonload：待資料回傳後啟動下一步onload 是等到資料回傳後(也就是 readyState: 4)，才會觸發去執行 function 的關鍵語法。\nlet xhr = new XMLHttpRequest()let url = &#x27;https://hexschool.github.io/ajaxHomework/data.json&#x27;xhr.open(&#x27;get&#x27;, url, true)xhr.send()xhr.onload = function()&#123;        console.log(xhr.responseText);&#125;\n\n\n\nXMLHttpRequest 發請求流程整理\n建立 XMLHttpRequest\n傳送請求到對方伺服器要資料\n資料回傳到自己的瀏覽器\n\n\n\n\n參考資料輕鬆理解 Ajax 與跨來源請求\n\n\n\n","categories":["JavaScript","AJAX"],"tags":["JavaScript"]},{"title":"JavaScript 時間戳轉換日期的方法","url":"/2021/12/19/2021-12-JavaScript-%E6%99%82%E9%96%93%E6%88%B3%E8%BD%89%E6%8F%9B%E6%97%A5%E6%9C%9F%E7%9A%84%E6%96%B9%E6%B3%95/","content":"new Date()：宣告時間物件new Date() 是 JS 的內建物件語法，可以用來宣告一筆時間物件資料。為什麼說 new Date() 是用來宣告時間的物件呢？因為如果使用 typeof 來檢查 new Date()，會發現它是一個物件(Object)。\n\n\nDate.now()：取得毫秒數字資料時間戳 (timestamp)時間戳是一種時間表示的方式，起始點是從格林威治時間（GMT）1970 年 1 月 1 日 00 時 00 分 00 秒持續至今的總秒數，由於在網頁開發常常會應用到一些時間功能，例如客戶下單的時間、行事曆，甚至也可以用來當作檔案編號，因為每一個時間的秒數，都是獨一無二的存在，因此也可以當 id 的概念來運用。\n\n\n取得毫秒數字資料在寫這篇文章的當下時間是 2021 年 12 月 14 日，當我要取得一個目前當下的時間，輸入這行程式碼就能得到一個時間戳，這個時間戳就是從 1970/01/01 00:00:00 起到現在這個當下所經過的毫秒數：\nlet now = Date.now(); //1639457229881\n\n但因為時間是一直往前進的，毫秒也會隨之一直增加，接下來，這筆毫秒數可以怎麼轉換成時間字串，顯示出一個過去的時間呢？\n\n\n取得時間字串資料：new Date() + 毫秒那麼 new Date() 和 Date.now 究竟可以怎麼結合起來使用呢？我們可以運用 new Date() 再加入毫秒，顯示出一個過去或未來的時間點，方法是透過在 new Date() 內傳入毫秒，接著 new Date() 會回傳一個時間物件資料，用法如下：\nlet time = new Date(1639457229881) \n\n\n\n\n\n取得當前時間.get() 方法取得特定時間(數字)再更進一步，如果我希望取得的是當前個別的年、月、日又該怎麼做？在以下的方法中，是透過以 new Date() 建立物件資料，取得一個時間字串，再透過以下 JS 方法轉換出指定的資訊，但要特別注意的是，這些轉換出來的時間是數字型別。\n\n\n取得目前個別年份：.getFullYear()let time = new Date()console.log(time.getFullYear()) // 2021 (number)\n\n\n\n取得目前個別月份：.getMonth()這邊要特別注意，因為程式是由 0 起算，getMonth() 回傳永遠會少 1(0~11是12)，因此要記得 +1 才是正確的月份！\nlet time = new Date()console.log(time.getMonth()) // 11 (number)\n\n\n\n取得目前個別日期：.getDate()let time = new Date()console.log(time.getDate()) // 14 (number)\n\n\n\n取得目前星期幾：.getDay()這邊值得注意的是：星期一是 1、星期二是 2…以此類推，而星期天是 0。\nlet time = new Date()console.log(time.getDay()) // 2 (number)\n\n此外，也還有：取得目前幾時 (0–23) .getHours()取得目前幾分 (0–59) .getMinutes()取得目前幾秒 (0–59) .getSeconds()取得目前幾毫秒 (0–999) .getMilliseconds()\n\n\n同步顯示年、月、日：.toLocaleDateString()這邊值得注意的是：取得的資料是字串(如字面意義所述)\nlet time = new Date()console.log(time.toLocaleDateString()) // 2021/12/14 (string)\n\n\n\n設定未來某一個時刻除了上述取得目前時間的各種方法，也有設定未來某一個時刻的方法。我們可以透過 .setFullYear(), .setMonth(), .setDate()…等，來取得未來某一年、某個月、某一天的毫秒數，再透過這筆毫秒數字，用 new Date() 轉換為字串。\n\n\nobj.setDate() 取得日期毫秒let time = new Date() // 宣告一個時間物件let tomorrowMseconds = time.setDate(15) // 取本月 15 號的毫秒數let tomorrowDate = new Date(tomorrowMseconds).toLocaleDateString()console.log(tomorrowDate) // 2021/12/15\n\n\n\n實際應用那麼，假設現在要讓日期能夠動態顯示在六天後，應該如何進行？\n步驟如下：\n\n先宣告一個今天的日期物件，用今天(2021/12/14)當作基準\n設定六天後是 2021/12/20\n透過 .setDate() 取得今天到六天後 2021/12/20 的毫秒數\n將得到的毫秒結果傳入 new Date() 得到指定日期\n\nlet now = new Date() //宣告時間物件let today = now.toLocaleDateString() //取得今天日期字串 2021/12/14let daysToAdd = 6let sixDaysLaterMseconds = now.setDate(now.getDate() + daysToAdd)let sixDaysLaterDate = new Date(sixDaysLaterMseconds) //2021/12/20\n\n\n\n總結總而言之，使用 JavaScript 處理時間，就是用時間戳的毫秒轉出字串資料，或是用字串資料轉為毫秒之間來回轉換，透過這樣的轉換，就可以組出任何你想要的日期組合了！\n參考資料\nHow to add number of days to today’s date?\nJavaScript Date setDate()\n\n","categories":["JavaScript","時間戳"],"tags":["JavaScript"]},{"title":"if 判斷式的巢狀結構","url":"/2021/12/16/2021-12-if-%E5%88%A4%E6%96%B7%E5%BC%8F%E7%9A%84%E5%B7%A2%E7%8B%80%E7%B5%90%E6%A7%8B/","content":"if 判斷式的結構\n由 if 和 else 組成，但若沒有 else，程式碼依然能夠執行。\n可透過比較運算子、邏輯運算子的運算得出 true 或 false。\n可轉換非布林值的值，除了 falsy 值以外的值 (空字串、數字0、NaN、null、undefined…)，都會被判定為 true。\n在每一個小括號 ( ) 內都有一個條件判斷的運算，當條件沒有符合，就再比對下一個條件，直到比對出 true 的一個結果為止。\n\nconst myCar = &#x27;Porsche&#x27;; if(myCar === &#x27;Volvo&#x27;)&#123;   console.log(&#x27;我開 Volvo&#x27;); &#125; else if (myCar === &#x27;Benz&#x27;)&#123;   console.log(&#x27;我開 Benz&#x27;); &#125; else if (myCar === &#x27;VolksWagen&#x27;)&#123;   console.log(&#x27;我開 VolksWagen&#x27;); &#125; else if (myCar === &#x27;Porsche&#x27;)&#123;   console.log(&#x27;我開 Porsche&#x27;); &#125; else &#123;   console.log(&#x27;我沒車！&#x27;); &#125; // 印出 &#x27;我開 Porsche&#x27;\n\nif 判斷式的巢狀結構很多人可能以為 if 判斷式是由 if, else if 和 else 組成，但其實 else if 的出現只是文字排版的緣故，看到底下程式碼將會恍然大悟！\nconst myCar = &#x27;Porsche&#x27;;if(myCar === &#x27;Volvo&#x27;)&#123;      console.log(&#x27;我開 Volvo&#x27;);&#125; else if (myCar === &#x27;Benz&#x27;)&#123;      console.log(&#x27;我開 Benz&#x27;);&#125; else if (myCar === &#x27;VolksWagen&#x27;)&#123;      console.log(&#x27;我開 VolksWagen&#x27;);&#125; else if (myCar === &#x27;Porsche&#x27;)&#123;      console.log(&#x27;我開 Porsche&#x27;);&#125; else &#123;      console.log(&#x27;我沒車！&#x27;);&#125;// 印出 &#x27;我開 Porsche&#x27;\n\n","categories":["JavaScript","流程判斷"],"tags":["JavaScript"]},{"title":"querySelectorAll 搭配屬性選取器","url":"/2021/12/17/2021-12-querySelectorAll-%E6%90%AD%E9%85%8D%E5%B1%AC%E6%80%A7%E9%81%B8%E5%8F%96%E5%99%A8/","content":"CSS 屬性選取器的長相：[ ]根據 MDN 的解釋 \n\n中文版CSS 屬性選擇器通過已經存在的屬性名或屬性值配對到元素。 \n\n\n英文版The CSS attribute selector matches elements based on the presence or value of a given attribute.\n\n\n\n屬性選取器選取 input 屬性以下方程式碼為例，意思是選取所有：\n\ninput 標籤：屬性 type，且值為 text\ninput 標籤：屬性 type，且值為 number\n\n// HTML&lt;input type=&quot;text&quot; name=&quot;imgUrl&quot;&gt;\n\n//JSconst inputs = document.querySelectorAll(&quot;input[type=text],input[type=number]&quot;);\n\n\n\n處理表格：querySelectorAll 搭配屬性選取器querySelectorAll 可以一次大量選取 input 上面的屬性，選取到多個 input 標籤，當要套用 validate.js 表格驗證的時候，可以使用。\n&lt;form id=&quot;myForm&quot;&gt;  &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;套票名稱&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;    &lt;p class=&quot;messages name&quot;&gt;&lt;/p&gt;  &lt;/div&gt;    &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;圖片網址&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;imgUrl&quot;&gt;    &lt;p class=&quot;messages imgUrl&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;景點地區&lt;/label&gt;    &lt;select name=&quot;area&quot;&gt;      &lt;option value=&quot;&quot; selected disabled&gt;選擇地區&lt;/option&gt;      &lt;option value=&quot;台北&quot;&gt;台北&lt;/option&gt;      &lt;option value=&quot;台中&quot;&gt;台中&lt;/option&gt;      &lt;option value=&quot;高雄&quot;&gt;高雄&lt;/option&gt;    &lt;/select&gt;    &lt;p class=&quot;messages area&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;套票金額&lt;/label&gt;    &lt;input type=&quot;number&quot; name=&quot;price&quot; min=&quot;0&quot;&gt;    &lt;p class=&quot;messages price&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;套票組數&lt;/label&gt;    &lt;input type=&quot;number&quot; name=&quot;group&quot; min=&quot;0&quot;&gt;    &lt;p class=&quot;messages group&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;套票星級&lt;/label&gt;    &lt;input type=&quot;number&quot; name=&quot;rate&quot; min=&quot;0&quot; max=&quot;10&quot;&gt;    &lt;p class=&quot;messages rate&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;input-form&quot;&gt;    &lt;label for=&quot;&quot;&gt;套票描述&lt;/label&gt;    &lt;textarea type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;/textarea&gt;    &lt;p class=&quot;messages description&quot;&gt;&lt;/p&gt;  &lt;/div&gt;  &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;新增套票&lt;/button&gt;&lt;/form&gt;\n\nconst inputs = document.querySelectorAll(&quot;input[type=text],input[type=number],select,textarea&quot;);inputs.forEach((item) =&gt; &#123;// console.log(item)   // console.log(item.nextElementSibling)  item.addEventListener(&quot;change&quot;, function() &#123;    //預設為空值    item.nextElementSibling.textContent = &quot;&quot;;        // 驗證回傳的內容    let errors = validate(form, constraints);    // console.log(errors)        //呈現在畫面上    if(errors)&#123;      // console.log(Object.keys(errors)) //keys -&gt; 屬性            Object.keys(errors).forEach(function(keys) &#123;        // console.log(keys);         document.querySelector(`.$&#123;keys&#125;`).textContent = errors[keys]         // errors.imgUrl -&gt; Img url 是必填欄位      &#125;)    &#125;  &#125;);&#125;);","categories":["JavaScript","DOM","CSS","套件","選取器"],"tags":["JavaScript"]},{"title":"switch 和 if 的差異和使用時機","url":"/2021/12/16/2021-12-if-%E5%92%8C-switch-%E7%9A%84%E5%B7%AE%E7%95%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F/","content":"這一篇主要在探討 JavaScript 中的 switch (switch-case) 和 if 判斷式(if-else statement) 之間有什麼異同，又應該如何判斷選用的時機？\n比較 switch 和 if 的運算過程首先，兩者在外觀上就有很大的差異，因此本文大致上是：\n\n比較兩者語法的異同。\n最後找出各自的強項，分析出適合選用的時機。\n\n(一) 強制轉型switch 不允許強制轉型switch 的預設機制就是 === 的判斷，直接比對變數 number 跟 case 的資料型別、再比較值，所以若是型別不同的將會第一時間被篩選掉，因此在底下 switch 範例中的 case ‘666’ 不會執行。\nconst number = 666;switch(number)&#123;case &#x27;666&#x27;: console.log(&#x27;答案是字串666&#x27;); break; case 666: console.log(&#x27;答案是數字666&#x27;); break; default: console.log(&#x27;都不對&#x27;); break; &#125; //印出 &#x27;答案是數字666&#x27;\n\nif 判斷式允許強制轉型，但可透過運用 === 避免被轉型：if 判斷式 ( ) 內的運算，若不希望被 JS 隱性轉型，要另外透過用 ===、!==、&gt;== ，指示運算過程不允許強制轉型，否則就會出現以下的狀況，明明答案要是數字666，卻印出字串666。\nconst number = 666; if(number == &#x27;666&#x27;)&#123;   console.log(&#x27;答案是字串666&#x27;); &#125; else if (number == 666)&#123;   console.log(&#x27;答案是數字666&#x27;); &#125; else &#123;   console.log(&#x27;都不對&#x27;); &#125; \n\n(二) 範圍取值switch 不擅於範圍取值相較之下，switch 就不太擅於進行範圍取值，若勉強要進行，它也不像 if 判斷式能運用到邏輯運算子來算出一個區間範圍（像是：介於…到…之間），頂多能做到以下範例中的比對，但記得要在 switch 的變數直接改為 true。相對來說，switch 還是在值與值之間的比對顯得會更加精準跟快速。\nlet salary = 38888; switch(true)&#123; case salary &gt;= 100000: console.log(&#x27;月收入十萬以上&#x27;); break; case salary &gt;= 50000: console.log(&#x27;月收入五萬以上&#x27;); break; case salary &gt;= 30000: console.log(&#x27;月收入三萬以上&#x27;); break; default: console.log(&#x27;低薪族啊 QAQ&#x27;); break; &#125; //印出 月收入三萬以上\n\nif 判斷式較為擅長進行範圍取值如同前面所提過，if 判斷式可透過比較運算子或邏輯運算子得出 true 或 false。\nlet salary = 26900; if(salary &gt;= 100000)&#123;    console.log(&#x27;月收入十萬以上&#x27;); &#125; else if (salary &gt;= 50000 &amp;&amp; salary &lt; 100000) &#123;    console.log(&#x27;月收入介於五萬以上，低於十萬元&#x27;); &#125; else if (salary &gt;= 25000 &amp;&amp; salary &lt; 50000) &#123;    console.log(&#x27;月收入介於兩萬五千元以上，低於五萬元&#x27;); &#125; else &#123;    console.log(&#x27;低薪族啊 QAQ&#x27;); &#125; // 印出 &#x27;月收入介於兩萬五千元以上，低於五萬元&#x27;\n\n\n(三) switch 沒有 break 就不會煞車在 switch 的程式碼中，沒有 break 來終止程式碼運行，就算已經有比對到 true 的結果，後方的 case 仍會繼續跑完；而 if 判斷式在比對到 true 的結果後，就會終止運算。\nconst myCar = &#x27;Benz&#x27;; switch(myCar) &#123; case &#x27;Volvo&#x27;: console.log(&#x27;我開 Volvo&#x27;); case &#x27;Benz&#x27;: console.log(&#x27;我開 Benz&#x27;); case &#x27;VolksWagen&#x27;: console.log(&#x27;我開 VolksWagen&#x27;); case &#x27;Porsche&#x27;: console.log(&#x27;我開 Porsche&#x27;); default: console.log(&#x27;我沒車！&#x27;); &#125; // 印出 // 我開 Benz // 我開 VolksWagen // 我開 Porsche // 我沒車！\n\n(四) default：當上述條件都不符合時，就執行const number = 777; switch(number)&#123; case 111: console.log(&#x27;答案是數字111&#x27;); case 222: console.log(&#x27;答案是數字222&#x27;); case 333: console.log(&#x27;答案是數字333&#x27;); case 444: console.log(&#x27;答案是數字444&#x27;); default: console.log(&#x27;以上都不對&#x27;); &#125; //印出 &#x27;以上都不對&#x27;\n\n(五) switch 可以沒有 default，如同 if 判斷式也可以沒有 elseconst number = 777; if(number === 777)&#123; console.log(&#x27;答案是數字777&#x27;); &#125; //印出 &#x27;答案是數字777&#x27; switch(number)&#123; case 777: console.log(&#x27;答案是數字777&#x27;); &#125; //印出 &#x27;答案是數字777&#x27;\n\n總結在看完以上的比較之後，發現 if 判斷式和 switch 之間，其實有很多相同和不同之處。嚴格真的要比較起來，其實沒有誰好壞之分，但可以說它們各有不同擅長的功能，在了解兩者的特性後，可依照自己的需求，在不同的使用時機下選用。\nswitch 的運用時機\n\n比對一個變數的值和另一個值的簡單判斷，switch 在效能上有效率。\nswitch 可以直接比對變數跟 case 後方的值。\nswitch 強制不允許資料轉型，運算上更為嚴謹。\n\nif 的運用時機\n\n能判斷 true 或 false。\n能判斷非布林值的值。\n能彈性決定是否強制轉型（switch 不允許資料轉型）。\n\n\n\n\n參考資料\nMDN — if…else\nMDN — switch\n控制判斷(運算子、if、switch)\nJS 筆記 — 控制判斷(if、else if、switch)\nJavaScript Switch Case — JS Switch Statement Example\n\n","categories":["JavaScript","流程判斷"],"tags":["JavaScript"]},{"title":"認識 const 的特性","url":"/2021/12/16/2021-12-var-let-const%EF%BC%9Aconst/","content":"\n\nconst 的使用時機用 const 來宣告的變數，被稱為「常數 (constant) 」，常數只可被讀取，但不允許更動。\n那什麼時機會用到 const 來宣告一個變數呢？例如：天上有一個太陽，太陽的數量是恆常不變的、或是一筆商品的定價，或任何你在開發上不希望被更動的資料等。\nconst 宣告的變數特性區塊作用域const 與 let 一樣，兩者所宣告的變數都是存在於區塊作用域，因此在 { } 外，將讀取不到值。\n&#123;   const today = &#x27;2021/10/13&#x27;;&#125;console.log(today);  // 顯示 today is not defined.\n不可重複宣告同一個變數及重新賦予值const 宣告過的變數，除了不可再一次用 const 重複宣告，也不可再重新賦予值。\n當以 const 宣告 sunNum 這個變數，並賦予值為 1，又要再一次用 const 宣告這個變數的時候，主控台回傳告知 sunNum 這個變數已經被宣告過了。\n接下來，如果要將 sunNum 重新賦予值為 100 的時候，也會得到主控台回傳「賦予值到常數」這個動作的報錯。\nconst sunNum = 1;const sunNum = 2; // Uncaught SyntaxError: Identifier &#x27;sunNum&#x27; has already been declaredsunNum = 100; // Uncaught TypeError: Assignment to constant variable.\n\n\n\n參考資料與圖片出處：\nJavaScript 變數作用域 Variable Scope\nJavaScript 那個 let, const, var 到底差在哪？\n語法與型別\n[JS學徒特訓班] JavaScript ES6 : var, let, const 差異\nWhy don’t we use var anymore?\nVar, Let, and Const — What’s the Difference?\nHow JavaScript variable scoping is just like multiple levels of government\n[JavaScript] Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找\n02 var、let、const 與 ES6 簡介\n我知道你懂 hoisting，可是你了解到多深？\nPhoto credit to David Monje on Unsplash\n\n","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的 hoisting","url":"/2021/12/16/2021-12-var-let-const%EF%BC%9A%E6%AF%94%E8%BC%83-var-%E8%88%87-let-%E7%9A%84-hoisting/","content":"在開始講 var 與 let 的差異之前，要先了解一下，變數宣告的過程 — — 變數的資料究竟要如何儲存到記憶體？\n變數與記憶體的原理賦予變數一個新的值，就會產生一個記憶體空間存放，要改變變數的值，必須要透過 =（一個等號）來賦予值。\n備註 宣告一個變數，但未賦予值，也會產生一個記憶體空間。\n宣告變數，但不賦予值當用 var 宣告一個變數 myFavoriteSinger 但不給它值，在變數宣告的同時電腦也會開啟一個記憶體空間，只是這時還沒有被賦予值，記憶體空間內的資料會是 undefined（如下所示）。\n\n\n宣告變數後，賦予值然而，當變數被賦予值 var myFavoriteSinger = ‘Bruno Major’，此時變數就會轉向另一個記憶體儲存 ‘Bruno Major’ 這一個字串（如下所示）。\n\n\n\n何謂「抬升(hoisting) 」？看完了變數宣告的過程，進入正題，何謂「抬升(hoisting) 」？\nvar &amp; undefined一般來說，程式碼的讀取順序會是由第一行到最後一行，但假設今天在第六行用 var 宣告一個變數 a，不過從第二行就要求印出這個變數 a 的值，結果卻會顯示為 undefined，代表這個變數 a 已被讀取到，只是此時它的值為 undefined。\nlet &amp; 未初始化同樣地，在第七行用 let 宣告一個變數 b，但在第三行就要先印出 b 的值，得到的結果卻與 var 宣告的變數 a 不同，會顯示「在 ‘b’ 初始化之前無法讀取到 ‘b’ 的值」。\nconsole.log(a); //undefinedconsole.log(b); // Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationvar a = 30;var a;let b = 50; \n結論其實不管是用 let 或 var 來宣告的變數都有「抬升」，只是 a 會印出 undefined，而用 let 宣告的變數 b 會顯示「在 ‘b’ 初始化之前無法讀取到 ‘b’ 的值。」\n特別值得注意的地方是，被 var 宣告的「變數 a 」有抬升，但變數 a 的值是沒有一起被抬升的，因為第二行的console.log(a) 並沒有印出在第五行 a 賦予的值 (30)。\n註1 這邊若有想要更深入了解有關抬升的概念，可參閱：我知道你懂 hoisting，可是你了解到多深？註2 function 也有 hoisting 的狀況。\n","categories":["JavaScript","變數與記憶體","hoisting"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的重複宣告","url":"/2021/12/16/2021-12-var-let-const%EF%BC%9A%E6%AF%94%E8%BC%83-var-%E8%88%87-let-%E7%9A%84%E9%87%8D%E8%A4%87%E5%AE%A3%E5%91%8A/","content":"var 與 let 比一比var 可重複宣告同一個變數，let 不行！所以 let 語法會替開發者自動過濾，提醒這個變數在前面已被使用過。\nvar 可重複宣告變數以 var 宣告過的變數可以再用 var 重複宣告一次，且變數也能重新賦值。\nvar a = 3;var a = 10;console.log(a); // a 的值為 10;a = 66;console.log(a); // a 的值為 66;\n\nlet 不可重複宣告變數let 宣告過的變數，不能再用 let 重複宣告第二次，但變數可以重新賦值。\nlet a = 3;let a = 10;console.log(a); // Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declareda = 15;console.log(a); // a 的值為 15;\n","categories":["JavaScript","變數"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的作用域","url":"/2021/12/16/2021-12-var-let-const%EF%BC%9A%E6%AF%94%E8%BC%83-var-%E8%88%87-let-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"var 與 let 比一比用 let 所宣告的變數範圍又更為聚焦、比 var 更為嚴謹。\nlet 的區塊作用域這邊以 let 在 if 條件式內宣告一個變數，並發現：以 let 宣告的變數只能在大括號的範圍內被讀取，在大括號以外就無法取得變數的值。\nfunction tellMyFavoriteSingerLately() &#123;  if (true) &#123;    let nameOfTheSinger = &#x27;Bruno Major&#x27;;    console.log(nameOfTheSinger, &#x27;(使用let來宣告的變數，印出的位置在區塊作用域之內)&#x27;);    // 顯示 Bruno Major (使用let來宣告的變數，印出的位置在區塊作用域之內)    &#125;     console.log(nameOfTheSinger, &#x27;(使用let來宣告的變數，印出的位置在函式作用域之內)&#x27;);     // nameOfTheSinger is not defined    &#125;    tellMyFavoriteSingerLately(); console.log(nameOfTheSinger, &#x27;(印出的位置在函式作用域之外)&#x27;);  // nameOfTheSinger is not defined\n\n備註if 判斷式及 for、while 迴圈皆有大括號語法。\nvar 的函式作用域這邊以 var 在 if 條件式內宣告一個變數，並發現：\n\n在 if 條件式的大括號以外，依然可以讀取得到這個用 var 宣告的變數。\nvar 宣告的變數，它的作用域範圍在整個函式之內，而在函式之外，就讀不到值了，故顯示 not defined。\n\nfunction tellMyFavoriteSingerLately() &#123;    if (true) &#123;      var nameOfTheSinger = &#x27;Bruno Major&#x27;;    &#125;    console.log(nameOfTheSinger, &#x27;(用var宣告變數，印出的位置在函式作用域之內)&#x27;); \t\t// 顯示 Bruno Major (用var來宣告的變數，印出的位置在函式作用域之內)  &#125;  tellMyFavoriteSingerLately();console.log(nameOfTheSinger, &#x27;(印出的位置在函式作用域之外)&#x27;); // nameOfTheSinger is not defined\n\nvar 函式作用域的潛在問題為什麼在 ES6 問世後，越來越少人用 var 來宣告變數？究竟原因為何？\n我們或許可試著從接下來的範例來窺知一二：\n假如在全域範圍(程式碼第 2 行)先以 var 宣告一個變數 myCarColor 賦予值為 ‘red’，在 if 判斷式內又再一次宣告 myCarColor 並賦予值為 ‘black’，最後印出 myCarColor 得到的結果，是 ‘black’。\n由此可得知，以 var 宣告的變數，在這些有大括號 { } 的程式碼（像是 if 判斷式及 for、while 迴圈）作用域範圍不夠精確，將導致大括號內的程式碼會污染到全域變數的問題。\n這就不難了解為什麼在 ES6 後，越來越多人愛用 let &amp; const 來宣告變數了。但理解 var 的性質仍是必要的，因為總難免會遇到需要維護舊程式碼的情況。\nvar myCarColor = &quot;red&quot;;    if (true) &#123;        var myCarColor = &quot;black&quot;;     &#125;        console.log(myCarColor) // 顯示 black","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"什麼是 DOM：DOM 與它的節點","url":"/2021/12/17/2021-12-%E4%BB%80%E9%BA%BC%E6%98%AF-DOM%EF%BC%9ADOM-%E8%88%87%E5%AE%83%E7%9A%84%E7%AF%80%E9%BB%9E/","content":"網頁的 Document這篇主要在介紹什麼是 DOM (文件物件模型)。但在開始探討 DOM 之前，不得不先提到 document！網頁開發經常看到的 document 其實是一包物件，只要在 dev tool 上面輸入 document，就會看到 document 涵蓋的是整個瀏覽器視窗。\nDOM Tree 的生成當開啟瀏覽器的時候，瀏覽器就會自動把 document 的內容解析出一個一個的 DOM。解析後的結構就像 DOM Tree (就想像是一棵蘋果樹好了 XD)。\nDOM Tree 上的每一個框格都代表一個節點 (node)，而這些節點被解析出來，就像是 document 底下一小包一小包的物件，日後都可以透過 JS 用物件取值的方式去存取。\n備註 document 這包物件開啟後，除了內含很多元素，也有很多類似像函式的東西。\n\n\n\n\n\nDOM 節點的三種類型每一個 DOM 的節點都像是一小包物件，裡面又分別存在各式各樣的 tag\n\nelement：即 HTML 元素節點，包括：&lt;html&gt;、&lt;head&gt;、&lt;body&gt;、&lt;a&gt;…\nattribute：即屬性節點，包括：&lt;href&gt;、&lt;style&gt;…\ntext：即文字節點。\n\n節點的用處以 element 節點為例，可以透過節點找到其對應 &lt;body&gt;、&lt;h1&gt; 或 &lt;a&gt; 的位置，於是就可以透過節點去選取或修改標籤！\n節點觀念：載入 JS 檔案依據 DOM 產生的原理，由於 document 必須在解析出節點後，才能讓 JS 選取到，因此 JS 檔案通常放在 &lt;body&gt; 最後一行，主要原因就是要先解析出節點，才能跑程式！\n","categories":["JavaScript","DOM"],"tags":["JavaScript"]},{"title":"同時搜尋到圖與文字：以 h1 包覆 logo","url":"/2021/12/16/2021-12-%E5%90%8C%E6%99%82%E6%90%9C%E5%B0%8B%E5%88%B0%E5%9C%96%E8%88%87%E6%96%87%E5%AD%97%EF%BC%9A%E4%BB%A5-h1-%E5%8C%85%E8%A6%86-logo/","content":"當在撰寫網頁時，如果想用 h1 標籤來包覆 logo 圖片，HTML 結構會是：\n&lt;h1&gt;    &lt;a href=&quot;＃&quot;&gt;&lt;img src=&quot;&quot;&gt;Karen&#x27;s Coding Notes&lt;/a&gt;&lt;/h1&gt;\n\n而在 CSS 則可以考慮選用 background-image 來置入 logo 圖片：\nh1 a &#123;  background-image: url(&#x27;https://reurl.cc/mLX1AM&#x27;)  background-repeat: no-repeat;  width: 262px;  height: 262px;  text-decoration: none;  color: #888;  display: block;&#125;\n\n此時，在瀏覽器上會顯示 logo 圖案，且在圖片之上也會顯示 a 標籤內的文字 Karen’s Coding Notes：\n到這裡，問題出現了，既然會用 h1 來包覆 logo 圖示，是代表 logo 被認定為這一頁的重要資訊，因為在網頁 SEO 的規則中，h1 意味著主要標題，一個網頁中也只能有一個。\n若 h1 是重要資訊，而爬蟲程式卻讀不到標籤內有文字，將會判定不符合 SEO 規定，因此內容不可空白。\n因此我們的目標是：\n\n在網頁架構中同時有 logo 圖示與字\n實際在頁面上又只顯示圖示而不要看見字\n\n由於 h1 本身就是一個區塊元素，那麼便可以考慮將文字推出區塊元素的原理，來進行文字的挪移。\n做法：\n\n用 text-indent: 101% 將文字推出 h1 之外\n用 overflow: hidden 將溢出區塊的部分都隱藏起來\n用 white-space: nowrap 強制這一串文字不換行\n\nh1 a &#123;  background-image: url(&#x27;https://reurl.cc/mLX1AM&#x27;);  background-repeat: no-repeat;  width: 262px;  height: 262px;  text-decoration: none;  color: #888;  display: block;  /*  將文字推出 &lt;h1&gt;  */  text-indent: 101%;  overflow: hidden;  white-space: nowrap;&#125;","categories":["CSS","背景","logo"],"tags":["CSS"]},{"title":"同層選取器？同層相鄰選取器？","url":"/2021/12/15/2021-12-%E5%90%8C%E5%B1%A4%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%9F%E5%90%8C%E5%B1%A4%E7%9B%B8%E9%84%B0%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%9F/","content":"本篇短文主要是解釋「同層選取器(General Sibling Combinator)」與「同層相鄰選取器(Adjacent Sibling Combinator)」兩者的使用時機，再以實例比較兩者之間的差異。\n\n\n\n\n同層選取器 A ~ B假設要將 h1 標籤以下的 p 段落全部統一改為綠色字設定時，可使用同層選取器，可觀察到除了 h1 標籤仍為瀏覽器設定的字色以外，其以下的 p 段落全都被改為綠色字。\n\n\nh1 ~ p &#123;    color: green;&#125;\n\n&lt;h1&gt;瀏覽器預設字&lt;/h1&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;\n\n\n\n\n\n\n\n同層相鄰選取器 A + B假設只要將 h1 標籤以下的第一個 p 段落改為綠色字設定，其餘都不更動，可使用同層相鄰選取器，可觀察到只有 h1 標籤底下的第一個 p 段落字色為綠色，其餘的 p 段落仍保持原始瀏覽器設定的字色。\nh1 + p &#123;    color: green;&#125;\n\n&lt;h1&gt;瀏覽器預設字&lt;/h1&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;\n\n\n","categories":["CSS","選取器"],"tags":["CSS"]},{"title":"淺談變數與它們的作用域","url":"/2021/12/16/2021-12-var-let-const%EF%BC%9A%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"在探討這三者的差異之前，應該要先來談一下，var, let, 和 const 的用途：\n當需要電腦協助儲存一筆資料到記憶體的時候，要透過 var, let 或 const 來宣告 (declare) 變數，將資料存到變數裡，變數則會儲存在電腦記憶體，往後再呼叫這個變數，便能拿到這筆資料。\n假設要告訴電腦，Karen 有 1 杯茶，Roger 有 3 杯茶，可以怎麼敘述呢？透過 let 就是在宣告 karenHasTea (變數)，並賦予變數的值為 1。註：這邊的等號是賦值運算子的一種。\nlet karenHasTea = 1;let rogerHasTea = 3;\n\n而當一個變數被宣告的同時，也會有一個作用域跟著這個變數，於是你可能又想問，什麼是「作用域 (variable scope) 」？\n簡單來說，作用域就是一個變數能夠被存取到的範圍，而這範圍又分為全域作用域和區域作用域。但是，全域作用域和區域作用域，到底又代表什麼意思呢？我們應該如何理解這兩種區域作用域的範圍？\n全域作用域 (Global Scope)前面提到，我們透過 var, let 或 const 來宣告一個變數。但是假如不透過它們「宣告」變數，直接對變數賦予一個值，這是可以的嗎？（是的，記者現在實地為您測試…）假設今天有一個變數為 myName，我賦予它一個字串值 ‘Karen’：\nmyName = &#x27;Karen&#x27;;\n\n然後我再度到 chrome 的 dev tool 呼叫 myName 這個變數，主控台顯示：\n\n\n由此可知，不透過 var, let 或 const 來宣告，myName 也是可以寫入資料的，只是這時沒有被宣告，它存在的範圍會是在「全域作用域」，既無法確認它來自哪裡，它可以被存取的範圍也有模糊不清的問題(後續將會舉例說明)，未被宣告過的 myName 是一個「全域屬性」，為避免發生遺憾…，\n請一定要記得宣告你的變數！宣告變數，像是這樣：\nlet myName = &#x27;Karen&#x27;;\n\n被宣告過的變數，可以想像成是在幫一個變數劃出存取範圍。當變數是在函式之外被宣告，它的作用範圍就是屬於全域作用域；相反地，在函式之內被宣告的變數，它的存取範圍就是在區域作用域，而區域作用域又可分為函式作用域和區塊作用域。那你可能又會想問，為什麼區域作用域內，又要再分函式作用域和區塊作用域？以下將開始說明。\n前情提要：JS 的前世今生在 JavaScript ES6 出現之前，沒有 let 和 const，只能靠 var 來宣告變數，而 var 宣告的變數就是在「函式作用域」，直到 ES6 之後有了 let 和 const，「區塊作用域」才應運而生。\n所以，函式作用域是什麼？它和區塊作用域又有何差別？\n區域作用域 (Local Scope)首先，要先來解釋何謂區域作用域？簡單來說，區域作用域是相對於全域作用域的概念，只要不是在全域的範圍內的，都是屬於區域作用域，像是 function 函式、if 判斷式、for 和 else 的迴圈內的範圍，都是屬於區域作用域，而 JavaScript 的區域作用域又可分為函式作用域與區塊作用域。\n函式作用域 (Function Scope)函式作用域的範圍是在函式之內。\nfunction tellMyFavoriteSingerLately() &#123;let myFavoriteSingerLately = &#x27;Bruno Major&#x27;;console.log(&#x27;在函式作用域內的字串&#x27;, myFavoriteSingerLately); // 顯示 &#x27;Bruno Major&#x27;&#125;tellMyFavoriteSingerLately();console.log(&#x27;在函式作用域外的字串&#x27;, myFavoriteSingerLately); // 顯示 myFavoriteSingerLately is not defined.\n\n為何函式外的 console.log 會印出 not defined 呢？因為 myFavoriteSingerLately 這個變數在函式內被宣告後，它的作用域僅限於函式內，在函式外的地方就讀取不到這個變數。\n備註undefined 與 is not defined 是不同的，not defined 所指的是這個變數在這個區域是不存在的，根本讀取不到；undefined 則是指出在記憶體中有這一筆變數資料，只是尚未被賦予值。\n區塊作用域 (Block Scope)區塊作用域的範圍是在大括號 { } 之內。\n&#123;   let myFavoriteSingerLately = &#x27;Bruno Major&#x27;;&#125;console.log(myFavoriteSingerLately);  // 顯示 myFavoriteSingerLately is not defined.\n\n為什麼在大括號外的 console.log 會印出 not defined 呢？因為 myFavoriteSingerLately 這個變數在大括號內被宣告後，它的作用域僅限於大括號內，在大括號以外的地方就讀取不到這個變數。\n透過以 let 宣告變數在函式作用域與區塊作用域的例子，解釋了這兩個作用域的涵蓋範圍。在理解了這兩種作用域的範圍後，將在下一篇更進一步探討，var 和 let 的差異。\n","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"什麼是 DOM：DOM API 的背後原理","url":"/2021/12/17/2021-12-%E4%BB%80%E9%BA%BC%E6%98%AF-DOM%EF%BC%9ADOM-API-%E7%9A%84%E8%83%8C%E5%BE%8C%E5%8E%9F%E7%90%86/","content":"如何選取 DOM選取 DOM 的方式，我們可以透過以下幾種選取器：\n\nquerySeletor()\nquerySeletorAll()\ngetElementByTagName()\ngetElementByClassName()\ngetElementById()\n\n//註 選取 class 要用加 .const el = document.getElementByClassName(&#x27;.title&#x27;)//註 選取 tag 不用加 . const el = document.getElementByTagName(h1)\n\nDOM 選取器的原理前面有稍微提過，document 這包物件一但啟用後，裡頭除了包含很多元素，也有很多類似像函式的東西，其概念很類似物件裡面包一個函式，如果用 document.four，就會選到物件裡的函式，而這些選取器就像是 document 物件內的函式。\nlet document = &#123;    one: 1,    two: &#x27;two&#x27;,    three: true,    four: function()&#123;        console.log(&#x27;這是一個函式，包在 document 物件中&#x27;)    &#125;&#125;\n","categories":["JavaScript","選取器","DOM"],"tags":["JavaScript"]},{"title":"強制轉型 (1) 布林值篇","url":"/2021/12/16/2021-12-%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-1-%E5%B8%83%E6%9E%97%E5%80%BC%E7%AF%87/","content":"JS 的強制轉型要開始探討 JavaScript 的強制轉型（coercion），也一樣是在談資料型別間如何轉換的問題。但因為不太可能記起所有的轉型變化，只能盡可能地去理解轉型的規則了。\n強制轉型的三大規則：\n\n強制轉型有分顯性轉型(explicit coercion)及隱性轉型(implicit coercion)。\n強制轉型將轉出：布林值、字串、數字。\n原始型別和物件型別這兩種值的轉換邏輯會不大一樣。(但目前只會先著重在紀錄原始型別的強制轉型)\n\n強制轉型的顯性與隱性轉型顯性轉型 透過手動的方式，以函式的方法轉換值的型別。隱性轉型 由 JS 主動來幫你轉。\n但總之，不管是人工透過函式或直接由 JS 幫你轉，最終也只會轉出布林值、字串、數字這三種型別。\n而在進入正題前，要先說明，本系列文章主要是參考 JavaScript type coercion explained 這篇文章分類的方式，再依我自己認為由簡單到複雜的程度，分別由布林值、字串、數字的順序來解釋強制轉型及其規則。\n布林值的顯性轉型如前言所述，顯性轉型是必須以手動方式透過函式的方法來進行型別的轉換，因此就以 Boolean(); 來舉例，不論是任何型別的值丟進函式 Boolean()，都會轉出布林值的結果。\n\n屬於 falsy 值的，透過函式則會轉出 false，\n屬於 truthy值的，在 Boolean() 也會轉出 true。\n\n// 轉出結果為 false 的組別console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(-0)); //false console.log(Boolean(+0)); //false console.log(Boolean(NaN)); //false console.log(Boolean(&quot;&quot;)); //false // 轉出結果為 true 的組別 console.log(Boolean(&quot; &quot;)); //true console.log(Boolean(&quot;0&quot;)); //true console.log(Boolean(&quot;1&quot;)); //true console.log(Boolean(1)); // true console.log(Boolean(&quot;hello&quot;)); //true console.log(Boolean(&#123;&#125;)); //true console.log(Boolean([])); //true \n\n至於 truthy值與 falsy 值到底怎麼分，可參閱下表的整理：\n\n\n▲ Truthy、Falsy 值列表 (原始資料來源為深入理解 TypeScript ，再另將表格整理後製表。)\n\n\n\n布林值的隱性轉型根據前述，隱性轉型就是透過 JS 自動幫忙轉型。而 if 判斷式的原理，就是當 ( ) 內的值為 true 的時候，就會執行 { } 內的動作。\nif(true) &#123;   console.log(&#x27;因為是 true 才回傳這一行字&#x27;);&#125;\n\n因此這邊以 if 判斷式舉例，且也可以從回傳的印出結果，證實 if 判斷式在 ( ) 內，確實也能把非布林值的值進行轉換。\n// 以字串為例：if(&quot;a string&quot;)&#123;    console.log(&#x27;顯示這段話的時候，就是字串 &quot;a string&quot; 被轉為 true 了&#x27;);  //顯示&#125; else &#123;   console.log(&#x27;只有在 &quot;a string&quot; 被判定為 false 的時候，才會顯示這段話&#x27;); &#125; // 以數字為例：if(365)&#123;    console.log(&#x27;顯示這段話的時候，就是數字365 被轉為 true 了&#x27;);  //顯示&#125; else &#123;    console.log(&#x27;只有在數字365 被判定為 false 的時候，才會顯示這段話&#x27;); &#125;// 以 NaN 為例：if(NaN)&#123;    console.log(&#x27;顯示這段話的時候，就是 NaN 被轉為 true 了&#x27;);  //顯示&#125; else &#123;    console.log(&#x27;只有在 NaN 被判定為 false 的時候，才會顯示這段話&#x27;); &#125;\n\n備註 除了在 if 判斷式，很多的運算子也會進行隱性轉型。\n","categories":["JavaScript","資料型別","原始型別","強制轉型"],"tags":["JavaScript"]},{"title":"強制轉型 (2) 字串篇","url":"/2021/12/16/2021-12-%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-2-%E5%AD%97%E4%B8%B2%E7%AF%87/","content":"字串的顯性與隱性轉型強制轉型的三大規則：\n\n強制轉型有分顯性轉型(explicit coercion)及隱性轉型(implicit coercion)。\n強制轉型將轉出：布林值、字串、數字。\n原始型別和物件型別這兩種值的轉換邏輯會不大一樣。(但目前只會先著重在紀錄原始型別的強制轉型)\n\n字串的顯性轉型\n字串的顯性轉型一樣是透過函式。\n透過回傳結果可觀察到 String() 將數字、布林值、null、undefined 轉為字串。\n\nlet a = 666666; let b = true; let c = false; let d = null; let e = undefined; console.log(String(a), typeof String(a)); // 回傳 666666 string console.log(String(b), typeof String(b)); // 回傳 true string console.log(String(c), typeof String(c)); // 回傳 false string console.log(String(d), typeof String(d)); // 回傳 null string console.log(String(e), typeof String(e)); // 回傳 undefined string console.log(d.toString()); //Uncaught TypeError: Cannot read properties of null (reading &#x27;toString&#x27;) console.log(e.toString()); //Uncaught TypeError: Cannot read properties of undefined (reading &#x27;toString&#x27;)\n\n備註String(value) 和 value.toString() 都是能強制轉型為字串的函式，但在 value.toString() 這個方法中，null 和 undefined 將無法轉為字串型別。\n字串的隱性轉型字串的隱性轉型，必要的條件是在算式中，至少其中一個值為字串，( + ) 運算子會觸發隱性轉型，以下組合都會轉出字串：\n\n字串 + 字串\n字串 + 數字\n字串 + 布林值\n字串 + undefined\n字串 + null\n字串 + NaN\n字串 + 數字 + null\n字串 + 物件\n字串 + 陣列\n\nlet a = &quot;3&quot; + &quot;3&quot;; let b = &quot;8&quot; + 3; let c = &quot;9&quot; + true; let d = undefined + &quot;3&quot;; let e = null + &quot;3&quot;; let f = NaN + &quot;aaa&quot;; let g = null + 111 + &quot;666&quot;; let h = &quot;here&quot; + &#123;&#125;; let i = &quot;here&quot; + []; console.log(a, typeof a); // 回傳 33 string console.log(b, typeof b); // 回傳 83 string console.log(c, typeof c); // 回傳 9true string console.log(d, typeof d); // 回傳 undefined3 string console.log(e, typeof e); // 回傳 null3 string console.log(f, typeof f); // 回傳 NaNaaa string console.log(g, typeof g); // 回傳 111666 string console.log(g, typeof h); // 回傳 here[object Object] string console.log(g, typeof i); // 回傳 here[object Object] string\n\n以上為布林值及字串的強制轉型，而下一篇將專注在整理數字的強制轉型，並比較多在討論比較運算子 == 寬鬆等於、!= 寬鬆不等於的隱性轉型過程。\n參考資料\nDay10 — 隱含的強制轉型\n[22] 強制轉型 — ToBoolean、Falsy、Truthy\nJavaScript type coercion explained\nMDN — Addition (+)\nJS 我轉型我又轉了打我阿笨蛋\n\n","categories":["JavaScript","資料型別","原始型別","強制轉型"],"tags":["JavaScript"]},{"title":"強制轉型 (3) 數字型別與轉型規則篇","url":"/2021/12/16/2021-12-%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-3-%E6%95%B8%E5%AD%97%E5%9E%8B%E5%88%A5%E8%88%87%E8%BD%89%E5%9E%8B%E8%A6%8F%E5%89%87%E7%AF%87/","content":"繼強制轉型的布林值、字串篇之後，本篇主要在歸納數字型別的強制轉型，並找出隱性轉型背後的原理。\n數字型別的顯性與隱性轉型強制轉型的三大規則：\n\n強制轉型有分顯性轉型(explicit coercion)及隱性轉型(implicit coercion)。\n強制轉型將轉出：布林值、字串、數字。\n原始型別和物件型別這兩種值的轉換邏輯會不大一樣。(但目前只會先著重在紀錄原始型別的強制轉型)\n\n數字的顯性轉型數字的顯性轉型一樣是透過函式，這邊將透過 Number() 為例說明，而根據印出的結果觀察到：\n\n透過 Number() 能轉為數字的，就會回傳數字\n透過 Number() 無法轉為數字的，會轉出 NaN（像是 undefined ）\n在運算過程當中，布林值 true 被 Number() 轉為數字 1、false 為數字 0\nnull、空字串將會被 Number() 轉為 數字 0\n\nlet a = &#x27;666666&#x27;; let b = &#x27;seven&#x27; let c = true; let d = false; let e = null; let f = undefined; let g = &quot;&quot;; console.log(Number(a), typeof Number(a)); // 回傳 666666 &#x27;number&#x27; console.log(Number(b), typeof Number(b)); // 回傳 NaN &#x27;number&#x27; console.log(Number(c), typeof Number(c)); // 回傳 1 &#x27;number&#x27; console.log(Number(d), typeof Number(d)); // 回傳 0 &#x27;number&#x27; console.log(Number(e), typeof Number(e)); // 回傳 0 &#x27;number&#x27; console.log(Number(f), typeof Number(f)); // 回傳 NaN &#x27;number&#x27; console.log(Number(g), typeof Number(g)); // 回傳 0 &#x27;number&#x27;\n\n備註 parseInt() 能將數字的字串取整數。\n數字的隱性轉型有運算子的時候，隱性轉型將自動把值轉換為數字型別進行運算，若無法轉為數字型別的，則會轉為字串。\n(一) 算術運算子算術運算子：加法let a = 3 + true //4 &#x27;number&#x27; let b = true + false //1 &#x27;number&#x27; let c = null + true; //1 &#x27;number&#x27; let d = null + 666; //666 &#x27;number&#x27; let e = undefined + 3; //NaN &#x27;number&#x27; // 無法轉換為數字的 undefined：console.log(undefined + null) // 回傳 NaN (number)\n\n備註 當 ( + ) 遇到字串就不會轉為數字型別！\n算術運算子：減法let a = 3 - true //2 &#x27;number&#x27; let b = true - false //1 &#x27;number&#x27; let c = null - true; //-1 &#x27;number&#x27; let d = null - 666; //-666 &#x27;number&#x27; let e = undefined - 3; //NaN &#x27;number&#x27;\n\n算術運算子：乘、除法let a = 3 * &quot;6&quot;; // 18 &#x27;number&#x27; let b = true * &quot;3&quot;;// 3 &#x27;number&#x27; let c = undefined * 3; // NaN &#x27;number&#x27; let d = undefined * &quot;3&quot;; // NaN &#x27;number&#x27; let e = undefined * true; // NaN &#x27;number&#x27; let f = null * 666; // 0 &#x27;number&#x27; let g = null * &quot;666&quot;; // 0 &#x27;number&#x27; let h = null * true; // 0 &#x27;number&#x27;\n\n註1：字串遇到乘法、除法都會轉為數字型別註2：任何值與 undefined 相乘、相除都是 NaN註3：任何值與 null 相乘、相除都是 0\n(二) 比較運算子在算術運算子整理到一段落後，接著是探討比較運算子 == 和 != 在強制轉型中的背後原理。\n為什麼是這兩個呢？因為首先需要知道：\n\n== 和 !=：著重在「值」的比較，因為不比較型別，所以可允許強制轉型發生作用。\n=== 及 !==：不允許強制轉型的發生，若不希望程式碼被強制轉型，請記得要使用 === 或 !==。\n\n\n\n\n\n\n\n符號\n特性\n\n\n\n一般相等\n==\n轉為相同型別，再比較兩者的值\n\n\n嚴格相等\n===\n先看型別，再看值\n\n\n不等於\n!=\n比較兩者的值，但不比較型別\n\n\n嚴格不等於\n!==\n先看型別，再看值\n\n\n備註 嚴格相等 === 與嚴格不等於 !== 皆不允許自動轉型！\n比較運算子：＝＝範例 1 == 的運算過程，為了要比較「值」，會執行隱性轉型的動作，可以視為是字串 ‘666’ 被隱性轉型為 Number(‘666’)，故得到運算結果為 true。而 === 會先比較型別、再比較「值」，因此 === 只要先發現型別不同，就回傳 false，所以不希望程式碼被 JS 隱性轉型的時候，就應該使用 ===。\n// 範例1 console.log(666 == &#x27;666&#x27;); // true console.log(666 === &#x27;666&#x27;); // false\n\n範例 2 true 跟 ‘1’ 都經歷了隱性轉型的過程，第一行程式碼可以視為是 Number(true) == Number(‘1’)，故得到 true。\n// 範例2console.log(true == &#x27;1&#x27;); //true console.log(true === &#x27;1&#x27;); //false\n\n範例 3 上述兩個範例都是能被轉換為數字型別的，但是，當遇到非字串也非布林值的狀況，結果會是如何？\n這邊在 == 的運算中，可以視 null 為 String(null)，所以是 ‘null’ 不等於空字串，故得到 false。原因是隱性轉型是由 JS 來幫你決定轉哪一種，運算子的運算過程中，會先自動轉為數字型別，若不能轉為數字的，會改而轉字串，再比較值。\n// 範例3console.log(null == &#x27;&#x27;); //false console.log(null === &#x27;&#x27;); //false\n\n\n\n比較運算子：！＝範例 1 為何 666 不等於 ‘666’ 是 true，但 666 不等於 ‘666’ 又變成 false?很關鍵的一點就在於，比較運算子 != 也是會忽略型別，並允許字串被轉換為數字，再比較「值」；相反地，!== 則是會優先比較型別，再看值。\n範例 2 遇到兩者都非數字的情況下，運算過程也可被視為是 Number(true) 跟 Number(‘1’) 的運算，得到 false 的結果。\n// 範例1 console.log(666 != &#x27;666&#x27;); // false console.log(666 !== &#x27;666&#x27;); // true // 範例2 console.log(true != &#x27;1&#x27;); // false console.log(true !== &#x27;1&#x27;); // true\n\n\n總結最後歸納出四個重點：\n\n強制轉型有分為顯性轉型與隱性轉型，不管哪一種轉型，也只會轉出布林值、字串或數字其中一種。\n顯性轉型都是以手動用函式的方法將值轉換為自己指定要的型別。\n隱性轉型是由 JS 來幫你決定轉哪一種，當有運算子的時候，會優先轉為數字型別；遇到無法轉為數字的，改而轉成字串，再比較值。\n承第 3 點，加法運算子是較為特殊的一種，若遇到有字串，則優先轉字串再比較值。\n\n\n\n參考資料\nMDN — Equality comparisons and sameness\nMDN — 算術運算子\n重新認識 JavaScript: Day 07 「比較」與自動轉型的規則\n何謂強制轉型、以及如何作到轉換型別？\nType Coercion in JavaScript\nDay11 — 寬鬆相等 VS. 嚴格相等\n[27] 強制轉型 — 寬鬆相等 ( == ) vs. 嚴格相等 ( === )\n[27–1] 強制轉型 — 番外篇 （ 運算子預設的規定 ex: ==、+ ）\n\n","categories":["JavaScript","資料型別","原始型別","強制轉型","比較運算子"],"tags":["JavaScript"]},{"title":"活用 CSS backgrounds 做滿版背景 (上)","url":"/2021/12/16/2021-12-%E6%B4%BB%E7%94%A8-CSS-backgrounds-%E5%81%9A%E6%BB%BF%E7%89%88%E8%83%8C%E6%99%AF-%E4%B8%8A/","content":"設計網頁版型的時候，經常會用一張滿版圖片來作為主視覺，以 CSS backgrounds 加入背景圖的方式來進行。\n最常用來做滿版主視覺的屬性有：\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-size\nbackground\n\n使用 background-repeat 節省背景圖檔容量首先，就先來談談，background-image, background-repeat, 與  background-color 的搭配應用，以及該如何節省背景圖檔的容量！\n在製作素面背景的時候，假設有一張背景圖的大小為寬 1200 px、高 675 px，當這張圖整張上傳的時候，檔案大小為 154KB。乍看一張背景圖檔不過是154 KB 不是特別有感，但如果你的網頁有300人次瀏覽，那麼就是46MB的流量了，長期累積下來也相當驚人。\n\n\n當遇到這樣的情況，建議可以先在 PS 用切片工具把背景圖切一小段下來，經過切圖之後的背景圖檔，只剩下一小塊約 21KB 左右的檔案大小，接著再使用這張裁切後的小圖，就同樣能達到原先直接用 background-image 置入一整張大圖的效果，節省流量！\n\n\n不過，當容器內有文字，版面自動向下擴充時，由於背景的顏色有漸層，會產生畫面中顏色不連續的情形。\n\n\n不過，當容器內有文字，版面自動向下擴充時，由於背景的顏色有漸層，會產生畫面中顏色不連續的情形。所以這一張裁切後的小圖，還需搭配 background-repeat: repeat-x，以 X 軸重複顯示的方式來填滿視窗的背景，另外同時也要記得吸取不連續段落之間最下方的顏色，作為 background-color 背景色，就能解決顏色不連貫的問題了！\n.box&#123;    width: 1200px;    background-image: url(&#x27;./img/bg2.png&#x27;);    background-repeat: repeat-x;    background-color: #3fa9f5;&#125;\n\n總結：善用 background-repeat 節省檔案大小用背景圖進行版面設計時，必須考量到網頁效率問題，畢竟一張大的圖檔是很吃容量的，能預先考慮到背景圖該如何裁切能使其容量最精簡，對使用者來說，瀏覽網頁效率也能提高：background-repeat: no-repeat; 大張圖檔，只顯示一次background-repeat: repeat-x; 以X軸為基準重複background-repeat: repeat-y; 以Y軸為基準重複\n交互運用 background-color 與 background-image當高度沒有寫固定，背景會隨容器中的內容增加而自動向下延伸，導致背景顏色出現不連貫時，可以填入 background-color 作為容器中背景圖的延伸，以求整體版面一致性。\n","categories":["CSS","背景"],"tags":["CSS"]},{"title":"為什麼 'true' == true 是 false?","url":"/2021/12/18/2021-12-%E5%AF%AC%E9%AC%86%E7%AD%89%E6%96%BC-%E8%88%87%E5%B8%83%E6%9E%97%E5%80%BC%E7%9A%84%E9%9A%B1%E6%80%A7%E8%BD%89%E5%9E%8B/","content":"為什麼 ‘true’ == true 是 false?\n這個問題和寬鬆等於 == 在遇到布林值，中間的隱性轉型有關。\n猜猜看以下四個運算式的結果？\nconsole.log(&#x27;false&#x27; == false)console.log(&#x27;false&#x27; == true)console.log(&#x27;true&#x27; == false)console.log(&#x27;true&#x27; == true)\n\n最終結果都是 false。\n在寬鬆等於 == 的其中有一方是布林值、一方是字串的時候，雙方都要轉為數字，再進行比較運算，所以 JS 會自動幫你照以下程序強制轉型：\n第一階段轉型：布林值轉數字也就是說， ‘true’ == true 會變成 ‘true’ == 1此時兩者還是不同型別，於是到下一個階段\n第二階段轉型：字串轉數字在第二階段字串轉成數字，但因為這邊的字串有英文字母，所以字串轉成 NaN (數字型別)。\n第三階段：數字型別比數字型別故最後等同於 ‘true’ == 1 轉成 NaN == 1，導出結果為 false。\n備註 NaN 不等於任何數字，它甚至不等於自己 (NaN == NaN 是 false)\nconsole.log(&#x27;1&#x27; == true) // trueconsole.log(&#x27;0&#x27; == false) // trueconsole.log(Number(true)) // 1console.log(Number(false)) // 0console.log(Number(&#x27;true&#x27;)) // NaN\n\n\n  See the Pen \n  Untitled by Karen Huang (@Coding_Snorlax)\n  on CodePen.\n\n\n\n\n\n參考資料ECMA 轉型規則Why does “true” == true show false in JavaScript?\n","categories":["JavaScript","強制轉型"],"tags":["JavaScript"]},{"title":"物件取值：用方括號取值","url":"/2021/12/16/2021-12-%E7%89%A9%E4%BB%B6%E5%8F%96%E5%80%BC%EF%BC%9A%E7%94%A8%E6%96%B9%E6%8B%AC%E8%99%9F%E5%8F%96%E5%80%BC/","content":"用方括號取值 (Bracket notation)百毒不侵的 [ ]obj[value]此處的 value 可以是一個字串、數字或布林，而方括號如此百毒不侵的關鍵是，不論字串、數字或布林，在 [ ] 內都會被強制轉型轉出字串！\n除了字串之外，也可以在 [ ] 中代入一個變數。\n\n\n在 [ ] 帶入字串console.log(pencilCase[&quot;brand&quot;])// 回傳 &quot;Kokuyo&quot; console.log(pencilCase[&quot;year&quot;])// 回傳 2020 console.log(pencilCase[&quot;contents&quot;]) // 回傳 [&#x27;ruler&#x27;, &#x27;pencil&#x27;, &#x27;pen&#x27;, &#x27;eraser&#x27;] console.log(pencilCase[&quot;01_price&quot;]) // 回傳 990\n\n\n\n在 [ ] 帶入數字用 [ ] 取值，如果是屬性字串的話，一定要在 [ ] 裏面加上雙引號，但如果是數字的話，則是可以加也可以不加雙引號，都可以讀取得到。主要原因是，[ ] 可以將數字強制轉型成字串，所以如果遇到數字屬性，也可以不加雙引號。\n備註 數字不可用點取值！\n\n  See the Pen \n  物件取值 by Karen Huang (@Coding_Snorlax)\n  on CodePen.\n\n\n更多相關文章Can JavaScript Object Keys Be Numbers or Non-string Values?\n\n\n在 [ ] 帶入變數在前述例子中，用方括號取值的時候，都會在屬性外面再加一組單引號 ‘ ‘ 或雙引號 “ “，因為這些屬性都是屬於原始型別資料，因此需要透過單引號或雙引號來選取這些屬性。\n\n\n為何要在物件中代入變數？當需要抓取物件內某一個屬性的值，再做其他運用，這時候可透過宣告一個新的變數，另外單獨儲存這一個值。\nlet myPencilCase = &#123;     &quot;price&quot;: 300,     &quot;contents&quot;: [ &quot;scissor&quot;, &quot;eraser&quot;, &quot;fountain pen&quot;] &#125; let stationary = &quot;contents&quot;; //在物件中代入變數console.log(myPencilCase[&quot;contents&quot;]); //回傳 [ &quot;scissor&quot;, &quot;eraser&quot;, &quot;fountain pen&quot;](3) console.log(myPencilCase[stationary]); //回傳 [ &quot;scissor&quot;, &quot;eraser&quot;, &quot;fountain pen&quot;](3) //代表已成功在物件中代入變數\n\n當透過方括號的物件取值代入變數的時候，也就等同於把 “contents” 這個字串代入到方括號內，因此兩種方法都可取得一樣的值。\n註 用點取值的方式無法取到變數，只能直接取到屬性。\n\n\n總結\n物件取值有兩種方式：用點( . ) 或用方括號 [ ] 取值。\n用點取值只能取到屬性名稱開頭為：\n\n\n英文字母\n漢字\n下底線 ( _ )\n錢字符號 ( $ )\n\n\n用點取值取不到的屬性，可以用方括號 [ ] 取值。\n當有需要從物件中抓取一筆值另作他用，可透過方括號 [ ] 取值代入變數來儲存這筆值。\n\n\n\n表格整理\n\n\n\n\n\n參考資料\n從零開始的學習 JS 生活-第五日之陣列與物件\nMDN — JavaScript 物件基礎概念\nMDN — 物件的使用\nJavaScript 核心篇 學習筆記: Chap.30 — 物件取值，新增與刪除\n\n","categories":["JavaScript","物件型別"],"tags":["JavaScript"]},{"title":"物件取值：用點取值","url":"/2021/12/16/2021-12-%E7%89%A9%E4%BB%B6%E5%8F%96%E5%80%BC%EF%BC%9A%E7%94%A8%E9%BB%9E%E5%8F%96%E5%80%BC/","content":"物件取值是在做什麼？物件裡面可以裝載很多資料，妥善的規劃程式碼結構，並懂得運用這些資料，可以讓程式碼更為精簡。當需要從物件取用這些資料的時候，就要透過物件取值，其中物件取值有兩種方法，一種是直接透過 . 來取值，另外一種則是以 [ ] 來取值。\n用點取值 (Dot notation)直接取到物件內的某一個屬性的值。\nconsole.log(pencilCase.brand)// 回傳 &quot;Kokuyo&quot;console.log(pencilCase.year)// 回傳 2020 console.log(pencilCase.contents) // 回傳 [&#x27;ruler&#x27;, &#x27;pencil&#x27;, &#x27;pen&#x27;, &#x27;eraser&#x27;] console.log(pencilCase.01_price) // 回傳 undefined\n\n01_price 這個屬性，用點取值抓不到資料，因此要改用方括號取值才行。\n可以直接用點取值的屬性當屬性名稱開頭為以下項目：\n\n英文字母\n漢字\n下底線 ( _ )\n錢字符號 ( $ )\n\n除此之外的都屬特殊字元，用方括號才取得到值。\n","categories":["JavaScript","物件型別"],"tags":["JavaScript"]},{"title":"認識 switch 的用法","url":"/2021/12/16/2021-12-%E8%AA%8D%E8%AD%98-switch-%E7%9A%84%E7%94%A8%E6%B3%95/","content":"switch 的基本結構主要由 switch, case, break 和 default 組成。\nswitch 的 (  )switch 的 ( ) 內，主要是一個變數，而變數的值可能是字串、布林值、數字、null、undefined，而這個變數將和 case 後面的值進行比對。\ncasecase 後面接的是判斷條件，角色和 if 判斷式中的 if 相似。\ndefaultdefault 的角色跟 if 判斷式中的 else 相似。break 的功能在於中斷程式碼，所以沒有 break，程式碼仍可執行，只是會把所有的 case 都跑完，得到的結果可能不精準，如何運用要看情況。\nswitch 的寫法const myCar = &#x27;Porsche&#x27;; switch(myCar) &#123; case &#x27;Volvo&#x27;: console.log(&#x27;我開 Volvo&#x27;); break; case &#x27;Benz&#x27;: console.log(&#x27;我開 Benz&#x27;); break; case &#x27;VolksWagen&#x27;: console.log(&#x27;我開 VolksWagen&#x27;); break; case &#x27;Porsche&#x27;: console.log(&#x27;我開 Porsche&#x27;); break; default: console.log(&#x27;我沒車！&#x27;); break; &#125; // 印出 &#x27;我開 Porsche&#x27;\n\n","categories":["JavaScript","流程判斷"],"tags":["JavaScript"]},{"title":"操作 HTML 屬性 (2) getAttribute 用來取值","url":"/2021/12/17/2021-12-%E6%93%8D%E4%BD%9C-HTML-%E5%B1%AC%E6%80%A7-2-getAttribute-%E7%94%A8%E4%BE%86%E5%8F%96%E5%80%BC/","content":"\n\n\n\ngetAttribute 用來取值getAttribute 是透過選取 element 的屬性名稱，得到屬性的值，既然是回傳一個值，因此 getAttribute 其實就是可以用來取值和組資料的！(關於 getAttribute 取值的部分會再和 dataset 另文討論)。\n\n\ngetAttribute 的寫法element.getAttribute(&quot;屬性名稱&quot;);\n\n來看看範例吧！假如今天我想要透過 JS 取得一個 id 上的值，搭配 dataset，可以這樣做：\n//HTML&lt;div id=&quot;this-year&quot; data-year=&quot;2021&quot;&gt;今年是2021年&lt;/div&gt;//JSlet element = document.querySelector(&#x27;#this-year-2021&#x27;); console.log(element.getAttribute(&#x27;id&#x27;));於是，根據這樣的設計：// element.getAttribute(&#x27;id&#x27;) 印出的結果會是 &#x27;this-year&#x27;// element.getAttribute(&#x27;data-year&#x27;) 印出的結果會是 &#x27;2021&#x27;所以取到的值還可以組一個資料，透過 textContent 渲染在畫面上let str = `$&#123;element.getAttribute(&#x27;id&#x27;)&#125; is $&#123;element.getAttribute(&#x27;data-year&#x27;)&#125;`element.textContent = str;\n\n\n\n\n\ngetAttribute 的值恆為字串\n用 getAttribute 取到的值，型別會是字串。\n如果有特殊需求，要用 parseInt 轉型為數字。\n\n\n\n\n  See the Pen \n  11/15 ☆☆☆☆☆ value vs getAttrValue by Karen Huang (@Coding_Snorlax)\n  on CodePen.\n\n\n備註 getAttribute 要選取的屬性不存在，就會回傳 null 或 &quot;&quot;。\n","categories":["JavaScript","DOM","HTML","屬性"],"tags":["JavaScript","HTML"]},{"title":"操作 HTML 屬性 (1) setAttribute 增設屬性與值","url":"/2021/12/17/2021-12-%E6%93%8D%E4%BD%9C-HTML-%E5%B1%AC%E6%80%A7-1-setAttribute-%E6%9B%B4%E6%94%B9%E5%B1%AC%E6%80%A7%E8%88%87%E5%80%BC/","content":"\n\n\n\nsetAttribute 增設屬性與值setAttribute 是可以同時用來增設 HTML 元素上的屬性以及屬性的值，由於這樣的特性，setAttribute 可以用來做很多事。\n\n\nsetAttribute 的寫法element.setAttribute(&quot;屬性名稱&quot;, &quot;屬性值&quot;);\n\n\n\nsetAttribute 增加 CSS 樣式搭配 CSS，就可以透過 setAttribute 來更改 HTML 元素的樣式！\n底下是一個 title text 由一般的 div 包裹著，它的文字要當成 title 實在太小了，如果不更動 HTML，只用加一個 class 的方式來改變字級，應該怎麼做？\n//HTML&lt;div id=&quot;title-text&quot;&gt;title text&lt;/div&gt;//JSlet element = document.querySelector(&#x27;#title-text&#x27;);\n\n透過 setAttribute 增加 element 的屬性與值，title text 的字級就會很明顯的變大了！\n//CSS 一樣要先寫好一個新的 class，假設要把字級變大，增加到 100px.style&#123;font-size: 100px&#125;//JSelement.setAttribute(&#x27;class&#x27;, &#x27;style&#x27;)\n\n\n\n\n\nsetAttribute 在 &lt;a&gt; 增加網址\n用 setAttribute 在綁定 DOM 的 &lt;a&gt; 上，修改它的 href 值，增加 google 網址\n用 setAttribute 在 &lt;a&gt; 上增加 target 屬性，增加 ‘_blank’ (跳轉網頁)\n\n\n\n\n  See the Pen \n  11/11 getAttribute / setAttribute by Karen Huang (@Coding_Snorlax)\n  on CodePen.\n\n\n","categories":["JavaScript","DOM","HTML","屬性"],"tags":["JavaScript","HTML"]},{"title":"淺談 HTML 的 data-* 屬性應用：組陣列、用 dataset 取值","url":"/2021/12/18/2021-12-%E6%B7%BA%E8%AB%87-HTML-%E7%9A%84-data-%E5%B1%AC%E6%80%A7%E6%87%89%E7%94%A8%EF%BC%9A%E7%B5%84%E9%99%A3%E5%88%97%E3%80%81%E7%94%A8-dataset-%E5%8F%96%E5%80%BC/","content":"\n\n\n\n\n前言在 HTML 結構中會看到很多標籤，h1, h2, p…，但你想過，這些標籤上的屬性(attribute)，它的功能是什麼嗎？其實屬性的功能都是在補充與這些 HTML 標籤有關的更多資訊！\n既然屬性是 HTML 標籤的補充資料，那想當然爾，這些資料必定有它的用處，而其中當要自定義資料的時候，會使用 data-* 這個屬性來儲存開發者所需的資料，但問題是，到底要怎麼取用到這些標籤上的資料？這些資料又能怎麼用？是本文想探討的問題。\n在研究 data-* 的取得方式和用法前，先來看看 HTML 元素上有哪些全域屬性吧。在 HTML 標籤上可以使用很多屬性，屬性又分全域屬性，以及在特定標籤上使用的非全域屬性。\n全域屬性全域屬性是在全部的標籤上都能共用的屬性，例如：\n// 全域屬性：class, id, style, data-* ...&lt;h1 class=&quot;main-title&quot;&gt;我是個主標&lt;/h1&gt;&lt;h2 id=&quot;another-title&quot;&gt;我是另一個title&lt;/h2&gt;&lt;p style=&quot;color: red;&quot;&gt;我是個段落&lt;/p&gt;&lt;div data-year=&quot;2021&quot;&gt;今年是西元 2021 年&lt;/div&gt;\n\n非全域屬性僅對特定標籤有作用的屬性，例如：\n// 非全域屬性：href, type, autoplay...&lt;a href=&quot;#&quot;&gt;一個連結&lt;/a&gt;&lt;link href=&quot;#&quot;&gt;&lt;button type=&quot;button&quot;&gt;&lt;/button&gt;&lt;input type=&quot;text&quot;&gt;&lt;video autoplay=&quot;false&quot;&gt;&lt;/video&gt;\n\n上述的所有標籤屬性，列出來只是要說明屬性與 HTML 元素之間是如何互相搭配應用的，接下來將主要記錄 data-* 屬性的用法。\n怎麼用 data-* 屬性？前面可看到屬性的功能都已經定下來了，但 data-* 屬性卻是能依照開發者自己所需要的資料來做設定的屬性，目的是方便開發過程中，可依照自己的需求在 data-* 屬性上面埋資料。但問題是， data-* 屬性到底可以怎麼用呢？\n舉例來說：現在有兩個 p 標籤上設定 data-user 屬性 (屬性要設定成什麼，由開發者自己定義)，其值分別為 “信箱” 跟 “密碼”。\n//HTML&lt;p class=&quot;alertMsg&quot; data-user=&quot;信箱&quot;&gt;&lt;/p&gt;&lt;p class=&quot;alertMsg&quot; data-user=&quot;密碼&quot;&gt;&lt;/p&gt;\nQ1 如何選取到 p 標籤？querySelectorAll + class選取器。querySelectorAll + 屬性選取器 (因為 data-* 是屬性)。\nQ2 如何取到 data-user 屬性的值？用 forEach 把兩個標籤都帶入，運用 dataset.user 取到值 (即：物件取值的概念)。\nQ3 取到的值，如何渲染到畫面上？綁定 DOM，用 forEach 把多個字串資料 用 textContent / innerHTML 渲染到畫面上。\n程式碼第一步透過 querySelectorAll 來選取 data-user 屬性：\n// (1) querySelectorAll + class 選取器用法 (只取一個 data-user)const data = document.querySelectorAll(&#x27;.alertMsg&#x27;)[0];// 用 (&#x27;.alertMsg&#x27;)[0]：只選到 user=&quot;信箱&quot;// (2) querySelectorAll + 屬性選取器用法 (取到所有 data-user)const data = document.querySelectorAll(&quot;[data-user]&quot;);// 用 querySelectorAll(&quot;[data-user]&quot;) // 選到 data-user=&quot;信箱&quot;、data-user=&quot;密碼&quot;\n\n第二步由於 querySelectorAll 會回傳陣列資料，因此可以開始用 forEach 來跑資料、取值：\nconst data = document.querySelectorAll(&quot;[data-user]&quot;);data.forEach(function(item)&#123;console.log(item) // &lt;p class=&quot;alertMsg&quot; data-user=&quot;信箱&quot;&gt;&lt;/p&gt;// &lt;p class=&quot;alertMsg&quot; data-user=&quot;密碼&quot;&gt;&lt;/p&gt;console.log(item.dataset)// 取到 &#123;user: &quot;信箱&quot;&#125;, &#123;user: &quot;密碼&quot;&#125;console.log(item.dataset.user) // 終於取到 &quot;信箱&quot;、&quot;密碼&quot;&#125;)\n\n第三步將 item.dataset.user 取出的值，賦予到 item 上，如此一來， forEach 每跑一次，就同步會把字串在畫面上劃入一次資料。\nconst data = document.querySelectorAll(&quot;[data-user]&quot;);let str = &#x27;&#x27;data.forEach(function(item)&#123;str = item.dataset.user;item.textContent = str;&#125;)\n\n\n\n總結由於 data-* 屬性 能用陣列來跑 forEach 的關係，在應用上，還能夠用陣列的 index 值來寫刪除資料的功能，詳細說明可以參考 JavaScript 初心者筆記: HTML 的自訂資料屬性 — data-*。\n此外，也能夠透過綁定監聽事件，用 e.target.dataset，進一步與網頁互動、取到開發者想要取得的值，詳細可參閱 codepen 的用法。\n\n\n參考資料[技術分享] 什麼是 HTML 5 中的資料屬性（data-* attribute）\nJS 筆記 — dataset 與 Array 的運用\nMDN — Attribute selectors\nWhat are HTML data attributes and how can we use them?\n","categories":["JavaScript","陣列","迴圈","HTML","屬性"],"tags":["HTML"]},{"title":"認識 undefined 與 null 的型別","url":"/2021/12/16/2021-12-%E8%AA%8D%E8%AD%98-undefined-%E8%88%87-null-%E7%9A%84%E5%9E%8B%E5%88%A5/","content":"在探討這三者的差異前，必須先知道在 JavaScript 裡面有分原始型別及物件型別 (見下圖) 。\n七種原始型別 ( Primitive Data Type )：\n字串 (string type)\n布林值 (Boolean type)\n數字 (number type)\n整數數值 (BigInt type)\nundefined (undefined type)\nnull (null type)\nsymbol (symbol type)\n\n隸屬原始型別：undefined 與 null上面特別列出了type，不是因為吃飽特閒，而是因為刻意要強調原始資料型別 (type)這件事。\n更仔細去看 MDN 文件的話，所有的原始資料型別都有原始值 (primitive value)，而這是不可被更改的值。\n例如：布林值有兩種原始值，true 及 false，而這兩種原始值不可更動（但如果是變數的值，就可以更動）。\n因此根據上面的資料來看，undefined 與 null 都是屬於原始資料型別！\n比較 undefined 與 nullundefined 作為值假如宣告一個變數 foo1，但不賦予值，變數的回傳是 undefined：\nlet foo1;console.log(foo1)// undefined\nnull 作為值但假如宣告一個變數 foo2，並賦予值為 null，變數的值就是 null：\nlet foo2 = null;console.log(foo2); // null\n\n也就是說，這兩者的差異在於「有沒有對變數賦予值」吧，哎唷，原來事情就是這麼簡單而已啊。\n不不不…!!!!!! 不是的。\n記得剛剛為什麼要特別去強調資料「型別」的type這件事嗎？\n請注意，型別和值是兩回事喔，如果剛剛的 console.log 顯示的是變數的值，那麼接下來用 typeof 來觀察，我們會發現：\n\nundefined 的值，型別為 undefined\nnull 的值，型別為 object\n\nundefined 作為值的型別假如用 typeof 查詢 undefined value，回傳：undefined\nconsole.log(typeof undefined) //undefined\n\nnull 作為值的型別但同樣用 typeof 查詢 null value，回傳：object\nconsole.log(typeof null) //object\n\n\n\n表格一：值與型別的回顧\n\n\n\n值 (value)\n型別 (typeof value)\n\n\n\n變數：未賦值\nundefined\nundefined\n\n\n變數：賦予「空值」\nnull\nobject\n\n\n\n\n\n以比較運算子驗證 undefined 與 null 的型別假如 undefined 的型別是 undefined，那 null 的型別怎麼會是 object？相傳 null 的型別為 object 是 javascript 從發明之初就有的 bug，若去更動會產生很多問題，而我們也可以透過 JavaScript 規範查詢，看看要如何理解這個 bug。\nnull value 的意義null value primitive value that represents the intentional absence of any object valuenull 是有意的要去指出一個物件的值是不存在的狀態。\nundefined value 的意義undefined value primitive value used when a variable has not been assigned a valueundefined 代表一個變數未被賦予值、尚未被初始化的狀態，所以每個變數在尚未被初始化前一定都有個 undefined 值。\n驗證 null 與 undefined 的型別：範例一如果是兩個不同型別的值，會被 !== 判定為不相等。\n\nundefined 的型別是 undefined\nnull 的型別是 object\n\n兩者型別不同，比較結果為 true。\nconsole.log(null !== undefined) // true\n\n範例二\nundefined 是變數在宣告的時候沒有賦予值\nnull 是賦予變數一個「空值」\n\n由於 == 會自動轉換成相同型別之後再進行比較，在相同型別底下，推測因 null 與 undefined 都是 falsy 值，故兩者會是相等的，結果是 true。\nconsole.log(null == undefined) // true\n\n註1：falsy 值並不等於 false，但本文並不會解釋 falsy 值，可參閱：Truthy 與 Falsy。註2：這邊特別注意的是，null、undefined 並不等於 0 喔！\n範例三如果 null 的資料型別是 object、undefined 的型別是 undefined，兩者型別不相等，所以比較結果為 false。\nconsole.log(null === undefine) // false\n\n\n\n\n表格二：比較運算子\n\n\n\n符號\n特性\n\n\n\n嚴格不等於\n!==\n兩個不同的值，被視為不相等\n\n\n一般相等\n==\n轉為相同型別，再比較兩者的值\n\n\n嚴格相等\n===\n先看型別，再看值\n\n\n註1 一般相等(equality operator)：會自動被轉型別。註2 嚴格相等(identity operator) ：被比較的兩個值都不會被自動轉換型別，若值為不同型別，被視為不相等。\n\n\n\nundefined 等於 not defined 嗎？最後，還要來比較一下 undefined 與 not defined，這兩者也是常常會很令人困惑的。但我先說，答案很肯定是：NO。\n既然現在已經知道，undefined 為 JS 七種資料型別之一，當宣告一個變數，但未賦予值，它預設的值就會是 undefined，這大概於類似電腦告訴你：「ㄟ，我知道是有這個人啦，但齁，我不知道是從哪裡來的啦，歹勢！」\n那什麼時候會出現 not defined 呢？當看到回傳 xxx is not defined 的時候，是代表某一個變數根本都還不存在，也就是說變數連被宣告的這個動作都還沒有，類似於電腦告訴你：「ㄟ，沒這個人啦，搞不好齁，他連投胎都還沒去！」\n參考資料\n嚴格不等於\n相等比較\n你懂 JavaScript 嗎？#4 型別（Types）\nAn Essential Guide to JavaScript null\nhttps://tc39.es/ecma262/#sec-null-value\nEverything about null in JavaScript\nTruthy 與 Falsy\n初學者第一坑 — typeof 運算子, 詳解 undefined\n\n","categories":["JavaScript","資料型別","原始型別","比較運算子"],"tags":["JavaScript"]},{"title":"邏輯運算子 (布林值運算)","url":"/2021/12/16/2021-12-%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E5%B8%83%E6%9E%97%E5%80%BC%E9%81%8B%E7%AE%97/","content":"邏輯運算子簡介邏輯運算子的三種符號\n\n&amp;&amp; (and)：當所有用 &amp;&amp; 連接的條件都是 true，就回傳 true，否則回傳 false\n|| (or)：所有用 || 連接的條件，只要其中有一個是 true，就回傳 true\n! (not)：!true 會回傳 false，而 !false 會回傳 true\n\n短路求值 (short-circuit evaluation)根據 MDN 文件的定義\n\n邏輯運算子通常被用於布林值；使用於布林值時，它們會回傳布林型態的值。然而，&amp;&amp; 和 || 運算子實際上是回傳兩指定運算元之一，因此用於非布林型態值時，它可能會回傳一個非布林型態的值。\n而上述這段話大概又可以再拆解出下面這兩個問題：\n\n什麼叫做短路求值？\n布林值、真值、虛值到底怎麼分？\n\n何謂短路求值？根據 MDN 的解釋：Short-circuit evaluationAs logical expressions are evaluated left to right, they are tested for possible “short-circuit” evaluation using the following rules:false &amp;&amp; anything is short-circuit evaluated to false.true || anything is short-circuit evaluated to true.The rules of logic guarantee that these evaluations are always correct. Note that the anything part of the above expressions is not evaluated, so any side effects of doing so do not take effect.\n也就是說：\n\n邏輯運算子的運算順序是：由左至右。\n在 &amp;&amp; 的運算中，可求出為 false 的值。\n在 || 的運算中，可求出為 true 的值。\n\n&amp;&amp; 邏輯運算子的短路求值舉例說明：從 MDN 已經知道定義了。但假如有 2 個以上的布林值用 &amp;&amp; 運算呢？這樣看可能會更清楚。從以下四個印出的結果，可以想像，&amp;&amp; 的運算過程只要遇到 false 就跳出停止，同時得到 false。\nconsole.log(true &amp;&amp; true); //回傳 trueconsole.log(false &amp;&amp; true); //回傳 falseconsole.log(true &amp;&amp; false &amp;&amp; true); //回傳 falseconsole.log(true &amp;&amp; true &amp;&amp; false &amp;&amp; true); //回傳 false\n\n|| 邏輯運算子的短路求值在遇到都是 false 的情況下，|| 才回傳 false；反之，只要有一個 true 就會回傳 true。但假如有兩個以上的布林值用 || 運算呢？那結果又會如何？從以下印出的結果，一樣可以想像為，|| 的運算過程只要遇到 true 就跳出停止，同時得到 true 的結果。\nconsole.log(true || true); //回傳 trueconsole.log(false || false); //回傳 falseconsole.log(true || false); //回傳 trueconsole.log(false || true || false); //回傳 true (在第二個true跳出)console.log(false &amp;&amp; false &amp;&amp; true &amp;&amp; true); // true(在第三個true跳出)\n\n小結看到這邊，大概可以歸納出何謂「短路賦值」：\n\n邏輯運算子 &amp;&amp; 的運算過程:會是由左至右，回傳第一個是 falsy 的值。若皆為 truthy，則回傳最後一個值。\n\n邏輯運算子 || 的運算過程:會是由左至右，回傳第一個是 truthy 的值。若皆為 falsy，則回傳最後一個值。\n\n\n以上的部分，都是邏輯運算子的布林值運算，但如果要運算非布林值的時候，又該如何判斷 true 或 false?因此下一篇將著重解釋非布林型態的值，並會探討真值 truthy 及虛值 falsy。\n","categories":["JavaScript","邏輯運算子"],"tags":["JavaScript"]},{"title":"邏輯運算子 (非布林值運算)","url":"/2021/12/16/2021-12-%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90-%E9%9D%9E%E5%B8%83%E6%9E%97%E5%80%BC%E9%81%8B%E7%AE%97/","content":"邏輯運算子轉換布林值首先還是先回顧一下，依照最基礎定義，&amp;&amp; 和 || 在運算「純」布林值的時候，會回傳 true、false，最基礎可發展出這八種變化：\nconsole.log(true &amp;&amp; true) // 回傳 trueconsole.log(true &amp;&amp; false) // 回傳 falseconsole.log(false &amp;&amp; true) // 回傳 falseconsole.log(false &amp;&amp; false) // 回傳 falseconsole.log(true || true) // 回傳 trueconsole.log(true || false) // 回傳 trueconsole.log(false || true) // 回傳 trueconsole.log(false || false) // 回傳 false\n\n邏輯運算子轉換非布林值邏輯運算子也同時能用於運算「非布林值」，並且會回傳真值、虛值，而這些「非布林值」當然就包括原始型別與物件型別：\n真值與虛值題目篇// 數字console.log(0 &amp;&amp; 1)//回傳值為 0console.log(0 || 1)//回傳值為 1// 字串console.log(&#x27;goodbye&#x27; &amp;&amp; &#x27;hello&#x27;) //回傳 &#x27;hello&#x27;console.log(&#x27;goodbye&#x27; || &#x27;hello&#x27;) //回傳 &#x27;goodbye&#x27;// null 及 undefinedconsole.log(null &amp;&amp; undefined) // 回傳 nullconsole.log(null || undefined) // 回傳 undefined// 物件 及 陣列console.log(&#123;&#125; &amp;&amp; []) // 回傳 arrayconsole.log(&#123;&#125; || []) // 回傳 object\n\n如果你看完邏輯運算子轉換非布林值的過程後，也跟我一樣很想問，為什麼會這樣？那麼在這邊就應該先了解一下何謂真值與虛值了(上面8題詳解在下方)。\n真值與虛值列表大集合分辨真值、虛值與布林值的要點 ：\n\n布林值 true 和 false 是原始資料型別的其中一種。\ntruthy 不等於 true、falsy 也不等於 false，它們是不同的東西。\nfalsy 以外的都是 truthy\n\n\n\n▲ Truthy、Falsy 值列表 (原始資料來源為深入理解 TypeScript ，再另將表格整理後製表。)\n看完 truthy、falsy 之後，應該能比較好理解邏輯運算子是如何運算非布林值的了吧！那麼讓我們再一次回顧剛剛的 8 題：\n真值與虛值解答篇// 數字console.log(0 &amp;&amp; 1)//回傳值為 0，為 falsyconsole.log(0 || 1)//回傳值為 1，為 truthy// 字串console.log(&#x27;goodbye&#x27; &amp;&amp; &#x27;hello&#x27;) //回傳 &#x27;hello&#x27;，字串是 truthyconsole.log(&#x27;goodbye&#x27; || &#x27;hello&#x27;) //回傳 &#x27;goodbye&#x27;，字串是 truthy// null 及 undefinedconsole.log(null &amp;&amp; undefined) // 回傳 null，是 falsyconsole.log(null || undefined) // 回傳 undefined，是 falsy// 物件 及 陣列console.log(&#123;&#125; &amp;&amp; []) // 回傳 array，陣列是 truthyconsole.log(&#123;&#125; || []) // 回傳 object，物件是 truthy\n\n希望看到這邊，你已經更理解邏輯運算子的運算過程了。\n不過，你知道嗎？其實邏輯運算子也跟 CSS 的 class、ID 一樣，有權重之分哪！\n邏輯運算子的權重有關邏輯運算子的權重，可以參考這篇 MDN。根據 MDN 的資料來看，&amp;&amp; 的權重為 6 分、|| 的權重為 5 分，因此當遇到 &amp;&amp; 與 || 在同一個運算式的時候，就會先算 &amp;&amp; 再算 ||。\nconsole.log(null || NaN &amp;&amp; &quot;hello&quot; &amp;&amp; 666 || &quot;0&quot;)\n\n在這個例子當中，電腦會先運算 NaN &amp;&amp; “hello” &amp;&amp; 666 這一段，再處理其餘的部分，因此回傳結果為 “0”。\n你，答對了嗎？\n參考資料\n用邏輯判斷 ||(OR) 及 &amp;&amp;(AND) 來改寫 if (短路求值 Short-circuit evaluation)\n[JS基礎]如何使用邏輯運算子 &amp;&amp; 和 ||\n重新認識 JavaScript: Day 08 Boolean 的真假判斷\n深入理解 TypeScript\n第29天-Truthy和Falsy\nMDN — 邏輯運算子\nMDN — 運算子優先序\n\n","categories":["JavaScript","邏輯運算子"],"tags":["JavaScript"]},{"title":"DOM API(二)：getElement(s)By-* 系列與 HTMLCollection 物件","url":"/2021/12/17/2021-12-DOM-API-%E4%BA%8C/","content":"\n\n在前一篇認識了 querySelector 及 querySelectorAll，而本篇要解釋的是選取 DOM 的 getElement(s)By-* 系列，並互相比較這兩種方法選取的 DOM 集合，有何不同。\n\n\ngetElementById VS querySelector 的差異?因為這兩種選取器一次都只能選取一個，因此也常常用來進行功能上的比較，但 getElementById 就只能選取單一個 ID (而本來網頁中的 ID 名稱也就只能有一個)；而至於 querySelector 則不挑食，可一個選取 class 或 ID。\n\n\nquerySelectorAll VS getElementsBy-* 系列的差異?既然有選取單一元素的選擇器，也就有一次選取多個元素的選取器。對應到 querySelectorAll 的 DOM 選取器，在本篇主要介紹的是 getElementsByClassName 及 getElementsByTagName。\n透過 getElementsBy-* 選擇器選取到的元素，回傳的會是物件，原因是， getElementsBy-* 選取的是 DOM 的 element 節點 ，(而 querySelectorAll 選的是指定的 class 名稱或屬性…)。而且是一個像陣列格式的物件，又被稱為 HTML Collection。\n為什麼說像陣列呢，原因有二：\n\n它在物件內的第一個屬性是從 0 起算，有類似陣列排序的概念。\n它的外圍包覆 { } ，因此雖然有著陣列的形式，但它本質上還是一個物件 。\n\n範例如下：\n//HTML&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;//JSconst itemCollection = document.getElementsByClassName(&#x27;item&#x27;)console.log(itemCollection)\n\n\n\n圖說 getElementsByClassName 選取的 HTML Collection 本質上仍是個物件\n由於 HTML Collection 這種「類陣列」的物件特性，便能用物件取值 (方括號取值) 的方式，來選取到 HTMLCollection 物件內的屬性。\n\n\nHTMLCollection 物件不可跑 forEach假如要用 HTMLCollection 來跑 forEach，就會得到 xxxx.forEach is not a function 的回應。\n總結getElementsByClassName 回傳 HTML Collection 物件，DOM 不能跑 forEachgetElementsByTagName 回傳 HTML Collection 物件，DOM 不能跑 forEachquerySelectorAll 回傳 nodelist (類陣列)，DOM 可以跑 forEach\n參考資料Nodelist — MDNDay03-深入理解網頁架構：DOM\n","categories":["JavaScript","選取器","DOM"],"tags":["JavaScript"]}]