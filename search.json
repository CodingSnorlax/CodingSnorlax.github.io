[{"title":"認識 const 的特性","url":"/2021/12/16/var,%20let,%20const%EF%BC%9Aconst/","content":"\n\nconst 的使用時機用 const 來宣告的變數，被稱為「常數 (constant) 」，常數只可被讀取，但不允許更動。\n那什麼時機會用到 const 來宣告一個變數呢？例如：天上有一個太陽，太陽的數量是恆常不變的、或是一筆商品的定價，或任何你在開發上不希望被更動的資料等。\nconst 宣告的變數特性區塊作用域const 與 let 一樣，兩者所宣告的變數都是存在於區塊作用域，因此在 { } 外，將讀取不到值。\n&#123;   const today = &#x27;2021/10/13&#x27;;&#125;console.log(today);  // 顯示 today is not defined.\n不可重複宣告同一個變數及重新賦予值const 宣告過的變數，除了不可再一次用 const 重複宣告，也不可再重新賦予值。\n當以 const 宣告 sunNum 這個變數，並賦予值為 1，又要再一次用 const 宣告這個變數的時候，主控台回傳告知 sunNum 這個變數已經被宣告過了。\n接下來，如果要將 sunNum 重新賦予值為 100 的時候，也會得到主控台回傳「賦予值到常數」這個動作的報錯。\nconst sunNum = 1;const sunNum = 2; // Uncaught SyntaxError: Identifier &#x27;sunNum&#x27; has already been declaredsunNum = 100; // Uncaught TypeError: Assignment to constant variable.\n\n\n\n參考資料與圖片出處：\nJavaScript 變數作用域 Variable Scope\nJavaScript 那個 let, const, var 到底差在哪？\n語法與型別\n[JS學徒特訓班] JavaScript ES6 : var, let, const 差異\nWhy don’t we use var anymore?\nVar, Let, and Const — What’s the Difference?\nHow JavaScript variable scoping is just like multiple levels of government\n[JavaScript] Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找\n02 var、let、const 與 ES6 簡介\n我知道你懂 hoisting，可是你了解到多深？\nPhoto credit to David Monje on Unsplash\n\n","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的 hoisting","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E6%AF%94%E8%BC%83%20var%20%E8%88%87%20let%20%E7%9A%84%20hoisting/","content":"在開始講 var 與 let 的差異之前，要先了解一下，變數宣告的過程 — — 變數的資料究竟要如何儲存到記憶體？\n變數與記憶體的原理賦予變數一個新的值，就會產生一個記憶體空間存放，要改變變數的值，必須要透過 =（一個等號）來賦予值。\n備註 宣告一個變數，但未賦予值，也會產生一個記憶體空間。\n宣告變數，但不賦予值當用 var 宣告一個變數 myFavoriteSinger 但不給它值，在變數宣告的同時電腦也會開啟一個記憶體空間，只是這時還沒有被賦予值，記憶體空間內的資料會是 undefined（如下所示）。\n\n\n宣告變數後，賦予值然而，當變數被賦予值 var myFavoriteSinger = ‘Bruno Major’，此時變數就會轉向另一個記憶體儲存 ‘Bruno Major’ 這一個字串（如下所示）。\n\n\n\n何謂「抬升(hoisting) 」？看完了變數宣告的過程，進入正題，何謂「抬升(hoisting) 」？\nvar &amp; undefined一般來說，程式碼的讀取順序會是由第一行到最後一行，但假設今天在第六行用 var 宣告一個變數 a，不過從第二行就要求印出這個變數 a 的值，結果卻會顯示為 undefined，代表這個變數 a 已被讀取到，只是此時它的值為 undefined。\nlet &amp; 未初始化同樣地，在第七行用 let 宣告一個變數 b，但在第三行就要先印出 b 的值，得到的結果卻與 var 宣告的變數 a 不同，會顯示「在 ‘b’ 初始化之前無法讀取到 ‘b’ 的值」。\nconsole.log(a); //undefinedconsole.log(b); // Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationvar a = 30;var a;let b = 50; \n結論其實不管是用 let 或 var 來宣告的變數都有「抬升」，只是 a 會印出 undefined，而用 let 宣告的變數 b 會顯示「在 ‘b’ 初始化之前無法讀取到 ‘b’ 的值。」\n特別值得注意的地方是，被 var 宣告的「變數 a 」有抬升，但變數 a 的值是沒有一起被抬升的，因為第二行的console.log(a) 並沒有印出在第五行 a 賦予的值 (30)。\n註1 這邊若有想要更深入了解有關抬升的概念，可參閱：我知道你懂 hoisting，可是你了解到多深？註2 function 也有 hoisting 的狀況。\n","categories":["JavaScript","變數與記憶體","hoisting"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的重複宣告","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E6%AF%94%E8%BC%83%20var%20%E8%88%87%20let%20%E7%9A%84%E9%87%8D%E8%A4%87%E5%AE%A3%E5%91%8A/","content":"var 與 let 比一比var 可重複宣告同一個變數，let 不行！所以 let 語法會替開發者自動過濾，提醒這個變數在前面已被使用過。\nvar 可重複宣告變數以 var 宣告過的變數可以再用 var 重複宣告一次，且變數也能重新賦值。\nvar a = 3;var a = 10;console.log(a); // a 的值為 10;a = 66;console.log(a); // a 的值為 66;\n\nlet 不可重複宣告變數let 宣告過的變數，不能再用 let 重複宣告第二次，但變數可以重新賦值。\nlet a = 3;let a = 10;console.log(a); // Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declareda = 15;console.log(a); // a 的值為 15;\n","categories":["JavaScript","變數"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的作用域","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E6%AF%94%E8%BC%83%20var%20%E8%88%87%20let/","content":"var 與 let 比一比用 let 所宣告的變數範圍又更為聚焦、比 var 更為嚴謹。\nlet 的區塊作用域這邊以 let 在 if 條件式內宣告一個變數，並發現：以 let 宣告的變數只能在大括號的範圍內被讀取，在大括號以外就無法取得變數的值。\nfunction tellMyFavoriteSingerLately() &#123;  if (true) &#123;    let nameOfTheSinger = &#x27;Bruno Major&#x27;;    console.log(nameOfTheSinger, &#x27;(使用let來宣告的變數，印出的位置在區塊作用域之內)&#x27;);    // 顯示 Bruno Major (使用let來宣告的變數，印出的位置在區塊作用域之內)    &#125;     console.log(nameOfTheSinger, &#x27;(使用let來宣告的變數，印出的位置在函式作用域之內)&#x27;);     // nameOfTheSinger is not defined    &#125;    tellMyFavoriteSingerLately(); console.log(nameOfTheSinger, &#x27;(印出的位置在函式作用域之外)&#x27;);  // nameOfTheSinger is not defined\n\n備註if 判斷式及 for、while 迴圈皆有大括號語法。\nvar 的函式作用域這邊以 var 在 if 條件式內宣告一個變數，並發現：\n\n在 if 條件式的大括號以外，依然可以讀取得到這個用 var 宣告的變數。\nvar 宣告的變數，它的作用域範圍在整個函式之內，而在函式之外，就讀不到值了，故顯示 not defined。\n\nfunction tellMyFavoriteSingerLately() &#123;    if (true) &#123;      var nameOfTheSinger = &#x27;Bruno Major&#x27;;    &#125;    console.log(nameOfTheSinger, &#x27;(用var宣告變數，印出的位置在函式作用域之內)&#x27;); \t\t// 顯示 Bruno Major (用var來宣告的變數，印出的位置在函式作用域之內)  &#125;  tellMyFavoriteSingerLately();console.log(nameOfTheSinger, &#x27;(印出的位置在函式作用域之外)&#x27;); // nameOfTheSinger is not defined\n\nvar 函式作用域的潛在問題為什麼在 ES6 問世後，越來越少人用 var 來宣告變數？究竟原因為何？\n我們或許可試著從接下來的範例來窺知一二：\n假如在全域範圍(程式碼第 2 行)先以 var 宣告一個變數 myCarColor 賦予值為 ‘red’，在 if 判斷式內又再一次宣告 myCarColor 並賦予值為 ‘black’，最後印出 myCarColor 得到的結果，是 ‘black’。\n由此可得知，以 var 宣告的變數，在這些有大括號 { } 的程式碼（像是 if 判斷式及 for、while 迴圈）作用域範圍不夠精確，將導致大括號內的程式碼會污染到全域變數的問題。\n這就不難了解為什麼在 ES6 後，越來越多人愛用 let &amp; const 來宣告變數了。但理解 var 的性質仍是必要的，因為總難免會遇到需要維護舊程式碼的情況。\nvar myCarColor = &quot;red&quot;;    if (true) &#123;        var myCarColor = &quot;black&quot;;     &#125;        console.log(myCarColor) // 顯示 black","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"淺談變數與它們的作用域","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"在探討這三者的差異之前，應該要先來談一下，var, let, 和 const 的用途：\n當需要電腦協助儲存一筆資料到記憶體的時候，要透過 var, let 或 const 來宣告 (declare) 變數，將資料存到變數裡，變數則會儲存在電腦記憶體，往後再呼叫這個變數，便能拿到這筆資料。\n假設要告訴電腦，Karen 有 1 杯茶，Roger 有 3 杯茶，可以怎麼敘述呢？透過 let 就是在宣告 karenHasTea (變數)，並賦予變數的值為 1。註：這邊的等號是賦值運算子的一種。\nlet karenHasTea = 1;let rogerHasTea = 3;\n\n而當一個變數被宣告的同時，也會有一個作用域跟著這個變數，於是你可能又想問，什麼是「作用域 (variable scope) 」？\n簡單來說，作用域就是一個變數能夠被存取到的範圍，而這範圍又分為全域作用域和區域作用域。但是，全域作用域和區域作用域，到底又代表什麼意思呢？我們應該如何理解這兩種區域作用域的範圍？\n全域作用域 (Global Scope)前面提到，我們透過 var, let 或 const 來宣告一個變數。但是假如不透過它們「宣告」變數，直接對變數賦予一個值，這是可以的嗎？（是的，記者現在實地為您測試…）假設今天有一個變數為 myName，我賦予它一個字串值 ‘Karen’：\nmyName = &#x27;Karen&#x27;;\n\n然後我再度到 chrome 的 dev tool 呼叫 myName 這個變數，主控台顯示：\n\n\n由此可知，不透過 var, let 或 const 來宣告，myName 也是可以寫入資料的，只是這時沒有被宣告，它存在的範圍會是在「全域作用域」，既無法確認它來自哪裡，它可以被存取的範圍也有模糊不清的問題(後續將會舉例說明)，未被宣告過的 myName 是一個「全域屬性」，為避免發生遺憾…，\n請一定要記得宣告你的變數！宣告變數，像是這樣：\nlet myName = &#x27;Karen&#x27;;\n\n被宣告過的變數，可以想像成是在幫一個變數劃出存取範圍。當變數是在函式之外被宣告，它的作用範圍就是屬於全域作用域；相反地，在函式之內被宣告的變數，它的存取範圍就是在區域作用域，而區域作用域又可分為函式作用域和區塊作用域。那你可能又會想問，為什麼區域作用域內，又要再分函式作用域和區塊作用域？以下將開始說明。\n前情提要：JS 的前世今生在 JavaScript ES6 出現之前，沒有 let 和 const，只能靠 var 來宣告變數，而 var 宣告的變數就是在「函式作用域」，直到 ES6 之後有了 let 和 const，「區塊作用域」才應運而生。\n所以，函式作用域是什麼？它和區塊作用域又有何差別？\n區域作用域 (Local Scope)首先，要先來解釋何謂區域作用域？簡單來說，區域作用域是相對於全域作用域的概念，只要不是在全域的範圍內的，都是屬於區域作用域，像是 function 函式、if 判斷式、for 和 else 的迴圈內的範圍，都是屬於區域作用域，而 JavaScript 的區域作用域又可分為函式作用域與區塊作用域。\n函式作用域 (Function Scope)函式作用域的範圍是在函式之內。\nfunction tellMyFavoriteSingerLately() &#123;let myFavoriteSingerLately = &#x27;Bruno Major&#x27;;console.log(&#x27;在函式作用域內的字串&#x27;, myFavoriteSingerLately); // 顯示 &#x27;Bruno Major&#x27;&#125;tellMyFavoriteSingerLately();console.log(&#x27;在函式作用域外的字串&#x27;, myFavoriteSingerLately); // 顯示 myFavoriteSingerLately is not defined.\n\n為何函式外的 console.log 會印出 not defined 呢？因為 myFavoriteSingerLately 這個變數在函式內被宣告後，它的作用域僅限於函式內，在函式外的地方就讀取不到這個變數。\n備註undefined 與 is not defined 是不同的，not defined 所指的是這個變數在這個區域是不存在的，根本讀取不到；undefined 則是指出在記憶體中有這一筆變數資料，只是尚未被賦予值。\n區塊作用域 (Block Scope)區塊作用域的範圍是在大括號 { } 之內。\n&#123;   let myFavoriteSingerLately = &#x27;Bruno Major&#x27;;&#125;console.log(myFavoriteSingerLately);  // 顯示 myFavoriteSingerLately is not defined.\n\n為什麼在大括號外的 console.log 會印出 not defined 呢？因為 myFavoriteSingerLately 這個變數在大括號內被宣告後，它的作用域僅限於大括號內，在大括號以外的地方就讀取不到這個變數。\n透過以 let 宣告變數在函式作用域與區塊作用域的例子，解釋了這兩個作用域的涵蓋範圍。在理解了這兩種作用域的範圍後，將在下一篇更進一步探討，var 和 let 的差異。\n","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"同層選取器？同層相鄰選取器？","url":"/2021/12/15/%E5%90%8C%E5%B1%A4%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%9F%E5%90%8C%E5%B1%A4%E7%9B%B8%E9%84%B0%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%9F/","content":"本篇短文主要是解釋「同層選取器(General Sibling Combinator)」與「同層相鄰選取器(Adjacent Sibling Combinator)」兩者的使用時機，再以實例比較兩者之間的差異。\n\n\n\n\n同層選取器 A ~ B假設要將 h1 標籤以下的 p 段落全部統一改為綠色字設定時，可使用同層選取器，可觀察到除了 h1 標籤仍為瀏覽器設定的字色以外，其以下的 p 段落全都被改為綠色字。\n\n\nh1 ~ p &#123;    color: green;&#125;\n\n&lt;h1&gt;瀏覽器預設字&lt;/h1&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;\n\n\n\n\n\n\n\n同層相鄰選取器 A + B假設只要將 h1 標籤以下的第一個 p 段落改為綠色字設定，其餘都不更動，可使用同層相鄰選取器，可觀察到只有 h1 標籤底下的第一個 p 段落字色為綠色，其餘的 p 段落仍保持原始瀏覽器設定的字色。\nh1 + p &#123;    color: green;&#125;\n\n&lt;h1&gt;瀏覽器預設字&lt;/h1&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;\n\n\n","categories":["CSS","選取器"],"tags":["CSS"]},{"title":"圖與文字同時可被搜尋到的技巧：以 h1 包覆 logo","url":"/2021/12/16/%E5%9C%96%E8%88%87%E6%96%87%E5%AD%97%E5%90%8C%E6%99%82%E5%8F%AF%E8%A2%AB%E6%90%9C%E5%B0%8B%E5%88%B0%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%BB%A5%20h1%20%E5%8C%85%E8%A6%86%20logo/","content":"當在撰寫網頁時，如果想用 h1 標籤來包覆 logo 圖片，HTML 結構會是：\n&lt;h1&gt;    &lt;a href=&quot;＃&quot;&gt;&lt;img src=&quot;&quot;&gt;Karen&#x27;s Coding Notes&lt;/a&gt;&lt;/h1&gt;\n\n而在 CSS 則可以考慮選用 background-image 來置入 logo 圖片：\nh1 a &#123;  background-image: url(&#x27;https://reurl.cc/mLX1AM&#x27;)  background-repeat: no-repeat;  width: 262px;  height: 262px;  text-decoration: none;  color: #888;  display: block;&#125;\n\n此時，在瀏覽器上會顯示 logo 圖案，且在圖片之上也會顯示 a 標籤內的文字 Karen’s Coding Notes：\n到這裡，問題出現了，既然會用 h1 來包覆 logo 圖示，是代表 logo 被認定為這一頁的重要資訊，因為在網頁 SEO 的規則中，h1 意味著主要標題，一個網頁中也只能有一個。\n若 h1 是重要資訊，而爬蟲程式卻讀不到標籤內有文字，將會判定不符合 SEO 規定，因此內容不可空白。\n因此我們的目標是：\n\n在網頁架構中同時有 logo 圖示與字\n實際在頁面上又只顯示圖示而不要看見字\n\n由於 h1 本身就是一個區塊元素，那麼便可以考慮將文字推出區塊元素的原理，來進行文字的挪移。\n做法：\n\n用 text-indent: 101% 將文字推出 h1 之外\n用 overflow: hidden 將溢出區塊的部分都隱藏起來\n用 white-space: nowrap 強制這一串文字不換行\n\nh1 a &#123;  background-image: url(&#x27;https://reurl.cc/mLX1AM&#x27;);  background-repeat: no-repeat;  width: 262px;  height: 262px;  text-decoration: none;  color: #888;  display: block;  /*  將文字推出 &lt;h1&gt;  */  text-indent: 101%;  overflow: hidden;  white-space: nowrap;&#125;","categories":["CSS","背景","logo"],"tags":["CSS"]},{"title":"活用 CSS backgrounds 做滿版背景 (上)","url":"/2021/12/16/%E6%B4%BB%E7%94%A8%20CSS%20backgrounds%20%E5%81%9A%E6%BB%BF%E7%89%88%E8%83%8C%E6%99%AF%20(%E4%B8%8A)/","content":"設計網頁版型的時候，經常會用一張滿版圖片來作為主視覺，以 CSS backgrounds 加入背景圖的方式來進行。\n最常用來做滿版主視覺的屬性有：\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-size\nbackground\n\n使用 background-repeat 節省背景圖檔容量首先，就先來談談，background-image, background-repeat, 與  background-color 的搭配應用，以及該如何節省背景圖檔的容量！\n在製作素面背景的時候，假設有一張背景圖的大小為寬 1200 px、高 675 px，當這張圖整張上傳的時候，檔案大小為 154KB。乍看一張背景圖檔不過是154 KB 不是特別有感，但如果你的網頁有300人次瀏覽，那麼就是46MB的流量了，長期累積下來也相當驚人。\n\n\n當遇到這樣的情況，建議可以先在 PS 用切片工具把背景圖切一小段下來，經過切圖之後的背景圖檔，只剩下一小塊約 21KB 左右的檔案大小，接著再使用這張裁切後的小圖，就同樣能達到原先直接用 background-image 置入一整張大圖的效果，節省流量！\n\n\n不過，當容器內有文字，版面自動向下擴充時，由於背景的顏色有漸層，會產生畫面中顏色不連續的情形。\n\n\n不過，當容器內有文字，版面自動向下擴充時，由於背景的顏色有漸層，會產生畫面中顏色不連續的情形。所以這一張裁切後的小圖，還需搭配 background-repeat: repeat-x，以 X 軸重複顯示的方式來填滿視窗的背景，另外同時也要記得吸取不連續段落之間最下方的顏色，作為 background-color 背景色，就能解決顏色不連貫的問題了！\n.box&#123;    width: 1200px;    background-image: url(&#x27;./img/bg2.png&#x27;);    background-repeat: repeat-x;    background-color: #3fa9f5;&#125;\n\n總結：善用 background-repeat 節省檔案大小用背景圖進行版面設計時，必須考量到網頁效率問題，畢竟一張大的圖檔是很吃容量的，能預先考慮到背景圖該如何裁切能使其容量最精簡，對使用者來說，瀏覽網頁效率也能提高：background-repeat: no-repeat; 大張圖檔，只顯示一次background-repeat: repeat-x; 以X軸為基準重複background-repeat: repeat-y; 以Y軸為基準重複\n交互運用 background-color 與 background-image當高度沒有寫固定，背景會隨容器中的內容增加而自動向下延伸，導致背景顏色出現不連貫時，可以填入 background-color 作為容器中背景圖的延伸，以求整體版面一致性。\n","categories":["CSS","背景"],"tags":["CSS"]}]