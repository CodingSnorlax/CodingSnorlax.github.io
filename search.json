[{"title":"JS 物件(object) 的基礎觀念","url":"/2021/12/16/JS%20%E7%89%A9%E4%BB%B6(object)%20%E7%9A%84%E5%9F%BA%E7%A4%8E%E8%A7%80%E5%BF%B5/","content":"在開始看物件取值之前，再看一看物件的基本定義吧！\n物件的結構屬性(key) ：用來取得資料的「位置」。值(value) ：有不同型別。\n在物件內，沒有順序性，只有屬性名稱與值。\n物件的功能物件是 JavaScript 的物件型別之一，理解它的方法就跟在認識真實世界中的實體物件一樣，JS 的物件內會有很多屬性，而屬性可以是一個原始型別的值、物件或陣列，這些資料可以構成一項物品的詳細資訊。\n假設有一個筆袋，這是它的資訊：\n一個 Kokuyo 的黑色筆袋2020 年出廠材質是棉布非手工製造內容物：一枝尺、一枝鉛筆、一枝原子筆，及一個橡皮擦售價：原價 990 元，使用會員卡打折後為 891 元\n而這筆資訊轉換為物件，可以這樣紀錄：\n宣告物件let pencilCase = &#123;      &quot;brand&quot;: &quot;Kokuyo&quot;,      &quot;year&quot;: 2020,      &quot;color&quot;: &quot;black&quot;,      &quot;material&quot;: &quot;cotton&quot;,      &quot;isHandmade&quot;: false,      &quot;contents&quot;: [&#x27;ruler&#x27;, &#x27;pencil&#x27;, &#x27;pen&#x27;, &#x27;eraser&#x27;],      &quot;01_price&quot;: 990,      &quot;02_price&quot;: 891 &#125;\n\n使用時機：記述詳細資訊\n讀取物件的屬性 (造訪資料)let product = &#123;//    屬性   值(value)    name: &quot;King Size Bed&quot;,    price: 3000,    color: &#x27;white&#x27;,&#125;console.log(personal.name) // &quot;King Size Bed&quot;console.log(personal.price) // 3000\n\n新增物件的屬性let product = &#123;//    屬性   值(value)    name: &quot;King Size Bed&quot;,    price: 3000,    color: &#x27;white&#x27;,&#125;product.id = &#x27;xiw9249204sp&#x27;console.log(product);// 回傳 &#123;name: &quot;King Size Bed&quot;, price: 3000, color: &#x27;white&#x27;, id: &#x27;xiw9249204sp&#x27;&#125;\n\n\n新增物件的屬性 &amp; 修改物件屬性內的值 :看起來都是用一樣的方法，但概念上有點不同。\n\n一個是新增一個全新的屬性到物件內\n一個是修改物件原有屬性的值\n\n重新賦予物件的值let personal = &#123;//    屬性   值(value)    name: &quot;Karen&quot;,    money: 3000,    pc: &quot;Mac M1 Max&quot;&#125;//語意：花了3000元買電腦personal.money -= 3000;//語意：增加購買條件 Mac M1 Max Ram36GB版personal.pc += &quot;Ram36GB版&quot;","categories":["JavaScript","物件型別"],"tags":["JavaScript"]},{"title":"JS 中的傳值與傳址 (傳址篇)","url":"/2021/12/16/JS-%E4%B8%AD%E7%9A%84%E5%82%B3%E5%80%BC%E8%88%87%E5%82%B3%E5%9D%80-%E5%82%B3%E5%9D%80%E7%AF%87/","content":"什麼是傳值？先前在傳值篇解釋過，在變數宣告並賦予值的過程中，變數是指向各個獨立的值，而這個值若是屬於「原始型別」，每一筆都將儲存在獨立的記憶體內，因此傳值的動作，可以理解為：變數指向的是另一份「複製」後的單獨記憶體。\n什麼是傳址？傳址是兩個變數共同指向同一個值，且這邊的值是屬於「物件型別」（它可能是物件、陣列或函式），因為傳址沒有複製值，當然不會有新的位址，可是兩個變數都指向同一筆資料，而這筆資料被儲存在某一個地點，並且有一個「位址 (address) 」。\nlet fruit1 = [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27; ] let fruit2 = fruit1; // 傳址 console.log(fruit2); // 回傳 [&#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;]\n\n傳址類似於 fruit 1 寫一張紙條給 fruit2，告訴它：「當你之後要找這筆陣列資料的時候，去紙條上這個地址就會找到。」\n\n\n傳址：兩個位址連動改變的現象既然 fruit1 與 fruit2 共用同一個陣列位址，當透過 fruit2 來刪減陣列內的資料會發現，在 fruit2 刪除陣列中的第一筆資料 orange，從 fruit1 查詢發現 orange 也一起不見了。\ndelete fruit2[0]; //刪除陣列中的第一筆資料 console.log(fruit1);\n\n\n\n▲ console.log(fruit1); 的結果\n傳址：重新賦予值假如對 fruit2 重新賦予值，fruit1 和 fruit2 各自會有什麼結果呢？根據回傳結果，可以得知，當對 fruit2 重新賦予值，fruit2 的值改變了，但 fruit1 仍然不受影響。\nlet fruit1 = [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27; ] let fruit2 = fruit1; // 傳址console.log(fruit2); // 回傳 [&#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;] fruit2 = [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;, &#x27;durian&#x27;] // 對 fruit2 重新賦予值 console.log(fruit2); // 回傳 [ &#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;, &#x27;durian&#x27;] console.log(fruit1); // 回傳 [&#x27;orange&#x27;, &#x27;papaya&#x27;, &#x27;guava&#x27;, &#x27;mango&#x27;]\n\n這可以理解為，當對變數重新賦予值的時候，電腦就會再開一個新的記憶體空間來儲存這個值，當有新的空間、就有新的位址，那麼兩個變數這時就各自指向獨立的值，不再互相影響了。\n\n\n再看一個更進階的例子：當我現在需要把物件的某一個屬性的值取出，因此我另外再宣告一個新的變數 stationary 儲存這個值，同時最後我用 console.log 驗證一下變數是否有成功代入物件。\nlet myPencilCase = &#123;    &quot;color&quot;: &quot;brown&quot;,    &quot;contents&quot;: [&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;],&#125;let stationary = &quot;contents&quot;;console.log(myPencilCase[&quot;contents&quot;])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;](4)console.log(myPencilCase[stationary])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;](4)//代表變數已經成功抓到我要的值\n\n經過宣告 stationary 這個新的變數，自此之後，只要一修改 “contents” 屬性的陣列資料，這兩個地方的資料都會同步串聯了，例如：這邊用push()來新增一筆陣列資料。\nmyPencilCase[&quot;contents&quot;].push(&#x27;eraser&#x27;); //新增一筆陣列資料console.log(myPencilCase[&quot;contents&quot;])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;, &#x27;eraser&#x27;](5)console.log(myPencilCase[stationary])//回傳[&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;, &#x27;eraser&#x27;](5)\n\n但唯一做一個動作，就會斷掉兩者的牽連，那就是：重新對變數 stationary 賦予值。\nlet myPencilCase = &#123;    &quot;color&quot;: &quot;brown&quot;,    &quot;contents&quot;: [&#x27;ruler&#x27;, &#x27;fountain pen&#x27;, &#x27;scissor&#x27;, &#x27;pencil&#x27;]&#125;let stationary = &quot;contents&quot;;myPencilCase[stationary] = [666]stationary = [&#x27;marker&#x27;]; //重新對變數 stationary 賦予值。console.log(myPencilCase[&quot;contents&quot;]) //回傳 [666]console.log(myPencilCase[stationary]) // 回傳 undefined\n\n這邊的 myPencilCase[“contents”] 之所以會回傳 [666]，是因為 stationary 重新賦予值之前，透過這個變數 stationary 已經修改了“contents”陣列的資料，因此最終陣列資料停留在[666]。\n但後面將 stationary 重新賦予值，因此最後一行的 console.log 已無法透過 stationary 這個變數在 myPencilCase 這個物件內讀取資料了，故回傳 undefined。\n\n\n\n小結：傳址的三個重點\n傳址指的是當超過一個以上的變數要存取同一筆物件型別的值(物件、陣列或函式)。\n傳址可視為有一個以上的變數都指向同一個位址、取用同一筆物件型別的值，因此透過任一個變數去修改值，所有的變數的值都會連動一起改變。\n傳址後的兩個變數 fruit1、fruit2，雖然都會到同一個位址去存取一筆物件型別的資料，但假如對其中任一的變數 fruit1 再重新賦予一個值，此時電腦將另新開一個記憶體空間來存放這一筆資料，這時的 fruit1 與 fruit2 就各自指向不同的記憶體空間、資料也不再互相連動了。\n\n\n\n\n總結傳值 複製一筆值、產生獨立的記憶體空間來儲存資料，因此假如後續再對任一變數重新賦予值，兩者之間也不會產生影響。\n傳址 變數 a 複製了一個「位址」到變數 b 那邊去，所以兩個變數共同指向的仍是同一筆值，因此若透過任一個變數來修改這個值，兩者都會產生連動的改變。\n傳址又重新對其中一個變數賦予值 對變數重新賦予值會產生一個新的記憶體空間，又會回到很像傳值的時候，這時兩個變數裡面的資料內容並不相同。而這邊很關鍵的重點就是在於有了「重新賦予值」的動作，產生一個新的記憶體空間來儲存資料，導致 fruit1 與 fruit2 兩個變數日後不再互相影響。\n\n\n\n表格：重點回顧\n\n\n\n產生新記憶體空間\n產生新位址\n修改其中一個變數是否影響其他變數\n對其中一個變數重新賦予值是否還會影響其他變數\n\n\n\n傳值\nＶ\nＶ\nＸ\nＸ\n\n\n傳址\nＸ\nＸ\nＶ\nＸ\n\n\n\n\n\n\n參考資料\n你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 — — Pass by value, or Pass by reference？\nby reference (傳參考)、by value(傳值)的差別\nJavascript pass by reference or value\nHow to get a grip on reference vs value in JavaScript\n深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？\nJS 變數傳遞探討：pass by value 、 pass by reference 還是 pass by sharing？\n\n","categories":["JavaScript","物件型別","變數與記憶體","資料型別"],"tags":["JavaScript"]},{"title":"if 判斷式的巢狀結構","url":"/2021/12/16/if-%E5%88%A4%E6%96%B7%E5%BC%8F%E7%9A%84%E8%9C%82%E5%B7%A2%E7%B5%90%E6%A7%8B/","content":"if 判斷式的結構\n由 if 和 else 組成，但若沒有 else，程式碼依然能夠執行。\n可透過比較運算子、邏輯運算子的運算得出 true 或 false。\n可轉換非布林值的值，除了 falsy 值以外的值 (空字串、數字0、NaN、null、undefined…)，都會被判定為 true。\n在每一個小括號 ( ) 內都有一個條件判斷的運算，當條件沒有符合，就再比對下一個條件，直到比對出 true 的一個結果為止。\n\nconst myCar = &#x27;Porsche&#x27;; if(myCar === &#x27;Volvo&#x27;)&#123;   console.log(&#x27;我開 Volvo&#x27;); &#125; else if (myCar === &#x27;Benz&#x27;)&#123;   console.log(&#x27;我開 Benz&#x27;); &#125; else if (myCar === &#x27;VolksWagen&#x27;)&#123;   console.log(&#x27;我開 VolksWagen&#x27;); &#125; else if (myCar === &#x27;Porsche&#x27;)&#123;   console.log(&#x27;我開 Porsche&#x27;); &#125; else &#123;   console.log(&#x27;我沒車！&#x27;); &#125; // 印出 &#x27;我開 Porsche&#x27;\n\nif 判斷式的巢狀結構很多人可能以為 if 判斷式是由 if, else if 和 else 組成，但其實 else if 的出現只是文字排版的緣故，看到底下程式碼將會恍然大悟！\nconst myCar = &#x27;Porsche&#x27;;if(myCar === &#x27;Volvo&#x27;)&#123;      console.log(&#x27;我開 Volvo&#x27;);&#125; else if (myCar === &#x27;Benz&#x27;)&#123;      console.log(&#x27;我開 Benz&#x27;);&#125; else if (myCar === &#x27;VolksWagen&#x27;)&#123;      console.log(&#x27;我開 VolksWagen&#x27;);&#125; else if (myCar === &#x27;Porsche&#x27;)&#123;      console.log(&#x27;我開 Porsche&#x27;);&#125; else &#123;      console.log(&#x27;我沒車！&#x27;);&#125;// 印出 &#x27;我開 Porsche&#x27;\n\n","categories":["JavaScript","流程判斷"],"tags":["JavaScript"]},{"title":"switch 和 if 的差異和使用時機","url":"/2021/12/16/if-%E5%92%8C-switch-%E7%9A%84%E5%B7%AE%E7%95%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F/","content":"這一篇主要在探討 JavaScript 中的 switch (switch-case) 和 if 判斷式(if-else statement) 之間有什麼異同，又應該如何判斷選用的時機？\n比較 switch 和 if 的運算過程首先，兩者在外觀上就有很大的差異，因此本文大致上是：\n\n比較兩者語法的異同。\n最後找出各自的強項，分析出適合選用的時機。\n\n(一) 強制轉型switch 不允許強制轉型switch 的預設機制就是 === 的判斷，直接比對變數 number 跟 case 的資料型別、再比較值，所以若是型別不同的將會第一時間被篩選掉，因此在底下 switch 範例中的 case ‘666’ 不會執行。\nconst number = 666;switch(number)&#123;case &#x27;666&#x27;: console.log(&#x27;答案是字串666&#x27;); break; case 666: console.log(&#x27;答案是數字666&#x27;); break; default: console.log(&#x27;都不對&#x27;); break; &#125; //印出 &#x27;答案是數字666&#x27;\n\nif 判斷式允許強制轉型，但可透過運用 === 避免被轉型：if 判斷式 ( ) 內的運算，若不希望被 JS 隱性轉型，要另外透過用 ===、!==、&gt;== ，指示運算過程不允許強制轉型，否則就會出現以下的狀況，明明答案要是數字666，卻印出字串666。\nconst number = 666; if(number == &#x27;666&#x27;)&#123;   console.log(&#x27;答案是字串666&#x27;); &#125; else if (number == 666)&#123;   console.log(&#x27;答案是數字666&#x27;); &#125; else &#123;   console.log(&#x27;都不對&#x27;); &#125; \n\n(二) 範圍取值switch 不擅於範圍取值相較之下，switch 就不太擅於進行範圍取值，若勉強要進行，它也不像 if 判斷式能運用到邏輯運算子來算出一個區間範圍（像是：介於…到…之間），頂多能做到以下範例中的比對，但記得要在 switch 的變數直接改為 true。相對來說，switch 還是在值與值之間的比對顯得會更加精準跟快速。\nlet salary = 38888; switch(true)&#123; case salary &gt;= 100000: console.log(&#x27;月收入十萬以上&#x27;); break; case salary &gt;= 50000: console.log(&#x27;月收入五萬以上&#x27;); break; case salary &gt;= 30000: console.log(&#x27;月收入三萬以上&#x27;); break; default: console.log(&#x27;低薪族啊 QAQ&#x27;); break; &#125; //印出 月收入三萬以上\n\nif 判斷式較為擅長進行範圍取值如同前面所提過，if 判斷式可透過比較運算子或邏輯運算子得出 true 或 false。\nlet salary = 26900; if(salary &gt;= 100000)&#123;    console.log(&#x27;月收入十萬以上&#x27;); &#125; else if (salary &gt;= 50000 &amp;&amp; salary &lt; 100000) &#123;    console.log(&#x27;月收入介於五萬以上，低於十萬元&#x27;); &#125; else if (salary &gt;= 25000 &amp;&amp; salary &lt; 50000) &#123;    console.log(&#x27;月收入介於兩萬五千元以上，低於五萬元&#x27;); &#125; else &#123;    console.log(&#x27;低薪族啊 QAQ&#x27;); &#125; // 印出 &#x27;月收入介於兩萬五千元以上，低於五萬元&#x27;\n\n\n(三) switch 沒有 break 就不會煞車在 switch 的程式碼中，沒有 break 來終止程式碼運行，就算已經有比對到 true 的結果，後方的 case 仍會繼續跑完；而 if 判斷式在比對到 true 的結果後，就會終止運算。\nconst myCar = &#x27;Benz&#x27;; switch(myCar) &#123; case &#x27;Volvo&#x27;: console.log(&#x27;我開 Volvo&#x27;); case &#x27;Benz&#x27;: console.log(&#x27;我開 Benz&#x27;); case &#x27;VolksWagen&#x27;: console.log(&#x27;我開 VolksWagen&#x27;); case &#x27;Porsche&#x27;: console.log(&#x27;我開 Porsche&#x27;); default: console.log(&#x27;我沒車！&#x27;); &#125; // 印出 // 我開 Benz // 我開 VolksWagen // 我開 Porsche // 我沒車！\n\n(四) default：當上述條件都不符合時，就執行const number = 777; switch(number)&#123; case 111: console.log(&#x27;答案是數字111&#x27;); case 222: console.log(&#x27;答案是數字222&#x27;); case 333: console.log(&#x27;答案是數字333&#x27;); case 444: console.log(&#x27;答案是數字444&#x27;); default: console.log(&#x27;以上都不對&#x27;); &#125; //印出 &#x27;以上都不對&#x27;\n\n(五) switch 可以沒有 default，如同 if 判斷式也可以沒有 elseconst number = 777; if(number === 777)&#123; console.log(&#x27;答案是數字777&#x27;); &#125; //印出 &#x27;答案是數字777&#x27; switch(number)&#123; case 777: console.log(&#x27;答案是數字777&#x27;); &#125; //印出 &#x27;答案是數字777&#x27;\n\n總結在看完以上的比較之後，發現 if 判斷式和 switch 之間，其實有很多相同和不同之處。嚴格真的要比較起來，其實沒有誰好壞之分，但可以說它們各有不同擅長的功能，在了解兩者的特性後，可依照自己的需求，在不同的使用時機下選用。\nswitch 的運用時機\n\n比對一個變數的值和另一個值的簡單判斷，switch 在效能上有效率。\nswitch 可以直接比對變數跟 case 後方的值。\nswitch 強制不允許資料轉型，運算上更為嚴謹。\n\nif 的運用時機\n\n能判斷 true 或 false。\n能判斷非布林值的值。\n能彈性決定是否強制轉型（switch 不允許資料轉型）。\n\n\n\n\n參考資料\nMDN — if…else\nMDN — switch\n控制判斷(運算子、if、switch)\nJS 筆記 — 控制判斷(if、else if、switch)\nJavaScript Switch Case — JS Switch Statement Example\n\n","categories":["JavaScript","流程判斷"],"tags":["JavaScript"]},{"title":"認識 const 的特性","url":"/2021/12/16/var,%20let,%20const%EF%BC%9Aconst/","content":"\n\nconst 的使用時機用 const 來宣告的變數，被稱為「常數 (constant) 」，常數只可被讀取，但不允許更動。\n那什麼時機會用到 const 來宣告一個變數呢？例如：天上有一個太陽，太陽的數量是恆常不變的、或是一筆商品的定價，或任何你在開發上不希望被更動的資料等。\nconst 宣告的變數特性區塊作用域const 與 let 一樣，兩者所宣告的變數都是存在於區塊作用域，因此在 { } 外，將讀取不到值。\n&#123;   const today = &#x27;2021/10/13&#x27;;&#125;console.log(today);  // 顯示 today is not defined.\n不可重複宣告同一個變數及重新賦予值const 宣告過的變數，除了不可再一次用 const 重複宣告，也不可再重新賦予值。\n當以 const 宣告 sunNum 這個變數，並賦予值為 1，又要再一次用 const 宣告這個變數的時候，主控台回傳告知 sunNum 這個變數已經被宣告過了。\n接下來，如果要將 sunNum 重新賦予值為 100 的時候，也會得到主控台回傳「賦予值到常數」這個動作的報錯。\nconst sunNum = 1;const sunNum = 2; // Uncaught SyntaxError: Identifier &#x27;sunNum&#x27; has already been declaredsunNum = 100; // Uncaught TypeError: Assignment to constant variable.\n\n\n\n參考資料與圖片出處：\nJavaScript 變數作用域 Variable Scope\nJavaScript 那個 let, const, var 到底差在哪？\n語法與型別\n[JS學徒特訓班] JavaScript ES6 : var, let, const 差異\nWhy don’t we use var anymore?\nVar, Let, and Const — What’s the Difference?\nHow JavaScript variable scoping is just like multiple levels of government\n[JavaScript] Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找\n02 var、let、const 與 ES6 簡介\n我知道你懂 hoisting，可是你了解到多深？\nPhoto credit to David Monje on Unsplash\n\n","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的 hoisting","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E6%AF%94%E8%BC%83%20var%20%E8%88%87%20let%20%E7%9A%84%20hoisting/","content":"在開始講 var 與 let 的差異之前，要先了解一下，變數宣告的過程 — — 變數的資料究竟要如何儲存到記憶體？\n變數與記憶體的原理賦予變數一個新的值，就會產生一個記憶體空間存放，要改變變數的值，必須要透過 =（一個等號）來賦予值。\n備註 宣告一個變數，但未賦予值，也會產生一個記憶體空間。\n宣告變數，但不賦予值當用 var 宣告一個變數 myFavoriteSinger 但不給它值，在變數宣告的同時電腦也會開啟一個記憶體空間，只是這時還沒有被賦予值，記憶體空間內的資料會是 undefined（如下所示）。\n\n\n宣告變數後，賦予值然而，當變數被賦予值 var myFavoriteSinger = ‘Bruno Major’，此時變數就會轉向另一個記憶體儲存 ‘Bruno Major’ 這一個字串（如下所示）。\n\n\n\n何謂「抬升(hoisting) 」？看完了變數宣告的過程，進入正題，何謂「抬升(hoisting) 」？\nvar &amp; undefined一般來說，程式碼的讀取順序會是由第一行到最後一行，但假設今天在第六行用 var 宣告一個變數 a，不過從第二行就要求印出這個變數 a 的值，結果卻會顯示為 undefined，代表這個變數 a 已被讀取到，只是此時它的值為 undefined。\nlet &amp; 未初始化同樣地，在第七行用 let 宣告一個變數 b，但在第三行就要先印出 b 的值，得到的結果卻與 var 宣告的變數 a 不同，會顯示「在 ‘b’ 初始化之前無法讀取到 ‘b’ 的值」。\nconsole.log(a); //undefinedconsole.log(b); // Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationvar a = 30;var a;let b = 50; \n結論其實不管是用 let 或 var 來宣告的變數都有「抬升」，只是 a 會印出 undefined，而用 let 宣告的變數 b 會顯示「在 ‘b’ 初始化之前無法讀取到 ‘b’ 的值。」\n特別值得注意的地方是，被 var 宣告的「變數 a 」有抬升，但變數 a 的值是沒有一起被抬升的，因為第二行的console.log(a) 並沒有印出在第五行 a 賦予的值 (30)。\n註1 這邊若有想要更深入了解有關抬升的概念，可參閱：我知道你懂 hoisting，可是你了解到多深？註2 function 也有 hoisting 的狀況。\n","categories":["JavaScript","變數與記憶體","hoisting"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的重複宣告","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E6%AF%94%E8%BC%83%20var%20%E8%88%87%20let%20%E7%9A%84%E9%87%8D%E8%A4%87%E5%AE%A3%E5%91%8A/","content":"var 與 let 比一比var 可重複宣告同一個變數，let 不行！所以 let 語法會替開發者自動過濾，提醒這個變數在前面已被使用過。\nvar 可重複宣告變數以 var 宣告過的變數可以再用 var 重複宣告一次，且變數也能重新賦值。\nvar a = 3;var a = 10;console.log(a); // a 的值為 10;a = 66;console.log(a); // a 的值為 66;\n\nlet 不可重複宣告變數let 宣告過的變數，不能再用 let 重複宣告第二次，但變數可以重新賦值。\nlet a = 3;let a = 10;console.log(a); // Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declareda = 15;console.log(a); // a 的值為 15;\n","categories":["JavaScript","變數"],"tags":["JavaScript"]},{"title":"比較 var 與 let 的作用域","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E6%AF%94%E8%BC%83%20var%20%E8%88%87%20let/","content":"var 與 let 比一比用 let 所宣告的變數範圍又更為聚焦、比 var 更為嚴謹。\nlet 的區塊作用域這邊以 let 在 if 條件式內宣告一個變數，並發現：以 let 宣告的變數只能在大括號的範圍內被讀取，在大括號以外就無法取得變數的值。\nfunction tellMyFavoriteSingerLately() &#123;  if (true) &#123;    let nameOfTheSinger = &#x27;Bruno Major&#x27;;    console.log(nameOfTheSinger, &#x27;(使用let來宣告的變數，印出的位置在區塊作用域之內)&#x27;);    // 顯示 Bruno Major (使用let來宣告的變數，印出的位置在區塊作用域之內)    &#125;     console.log(nameOfTheSinger, &#x27;(使用let來宣告的變數，印出的位置在函式作用域之內)&#x27;);     // nameOfTheSinger is not defined    &#125;    tellMyFavoriteSingerLately(); console.log(nameOfTheSinger, &#x27;(印出的位置在函式作用域之外)&#x27;);  // nameOfTheSinger is not defined\n\n備註if 判斷式及 for、while 迴圈皆有大括號語法。\nvar 的函式作用域這邊以 var 在 if 條件式內宣告一個變數，並發現：\n\n在 if 條件式的大括號以外，依然可以讀取得到這個用 var 宣告的變數。\nvar 宣告的變數，它的作用域範圍在整個函式之內，而在函式之外，就讀不到值了，故顯示 not defined。\n\nfunction tellMyFavoriteSingerLately() &#123;    if (true) &#123;      var nameOfTheSinger = &#x27;Bruno Major&#x27;;    &#125;    console.log(nameOfTheSinger, &#x27;(用var宣告變數，印出的位置在函式作用域之內)&#x27;); \t\t// 顯示 Bruno Major (用var來宣告的變數，印出的位置在函式作用域之內)  &#125;  tellMyFavoriteSingerLately();console.log(nameOfTheSinger, &#x27;(印出的位置在函式作用域之外)&#x27;); // nameOfTheSinger is not defined\n\nvar 函式作用域的潛在問題為什麼在 ES6 問世後，越來越少人用 var 來宣告變數？究竟原因為何？\n我們或許可試著從接下來的範例來窺知一二：\n假如在全域範圍(程式碼第 2 行)先以 var 宣告一個變數 myCarColor 賦予值為 ‘red’，在 if 判斷式內又再一次宣告 myCarColor 並賦予值為 ‘black’，最後印出 myCarColor 得到的結果，是 ‘black’。\n由此可得知，以 var 宣告的變數，在這些有大括號 { } 的程式碼（像是 if 判斷式及 for、while 迴圈）作用域範圍不夠精確，將導致大括號內的程式碼會污染到全域變數的問題。\n這就不難了解為什麼在 ES6 後，越來越多人愛用 let &amp; const 來宣告變數了。但理解 var 的性質仍是必要的，因為總難免會遇到需要維護舊程式碼的情況。\nvar myCarColor = &quot;red&quot;;    if (true) &#123;        var myCarColor = &quot;black&quot;;     &#125;        console.log(myCarColor) // 顯示 black","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"淺談變數與它們的作用域","url":"/2021/12/16/var,%20let,%20const%EF%BC%9A%E8%AE%8A%E6%95%B8%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"在探討這三者的差異之前，應該要先來談一下，var, let, 和 const 的用途：\n當需要電腦協助儲存一筆資料到記憶體的時候，要透過 var, let 或 const 來宣告 (declare) 變數，將資料存到變數裡，變數則會儲存在電腦記憶體，往後再呼叫這個變數，便能拿到這筆資料。\n假設要告訴電腦，Karen 有 1 杯茶，Roger 有 3 杯茶，可以怎麼敘述呢？透過 let 就是在宣告 karenHasTea (變數)，並賦予變數的值為 1。註：這邊的等號是賦值運算子的一種。\nlet karenHasTea = 1;let rogerHasTea = 3;\n\n而當一個變數被宣告的同時，也會有一個作用域跟著這個變數，於是你可能又想問，什麼是「作用域 (variable scope) 」？\n簡單來說，作用域就是一個變數能夠被存取到的範圍，而這範圍又分為全域作用域和區域作用域。但是，全域作用域和區域作用域，到底又代表什麼意思呢？我們應該如何理解這兩種區域作用域的範圍？\n全域作用域 (Global Scope)前面提到，我們透過 var, let 或 const 來宣告一個變數。但是假如不透過它們「宣告」變數，直接對變數賦予一個值，這是可以的嗎？（是的，記者現在實地為您測試…）假設今天有一個變數為 myName，我賦予它一個字串值 ‘Karen’：\nmyName = &#x27;Karen&#x27;;\n\n然後我再度到 chrome 的 dev tool 呼叫 myName 這個變數，主控台顯示：\n\n\n由此可知，不透過 var, let 或 const 來宣告，myName 也是可以寫入資料的，只是這時沒有被宣告，它存在的範圍會是在「全域作用域」，既無法確認它來自哪裡，它可以被存取的範圍也有模糊不清的問題(後續將會舉例說明)，未被宣告過的 myName 是一個「全域屬性」，為避免發生遺憾…，\n請一定要記得宣告你的變數！宣告變數，像是這樣：\nlet myName = &#x27;Karen&#x27;;\n\n被宣告過的變數，可以想像成是在幫一個變數劃出存取範圍。當變數是在函式之外被宣告，它的作用範圍就是屬於全域作用域；相反地，在函式之內被宣告的變數，它的存取範圍就是在區域作用域，而區域作用域又可分為函式作用域和區塊作用域。那你可能又會想問，為什麼區域作用域內，又要再分函式作用域和區塊作用域？以下將開始說明。\n前情提要：JS 的前世今生在 JavaScript ES6 出現之前，沒有 let 和 const，只能靠 var 來宣告變數，而 var 宣告的變數就是在「函式作用域」，直到 ES6 之後有了 let 和 const，「區塊作用域」才應運而生。\n所以，函式作用域是什麼？它和區塊作用域又有何差別？\n區域作用域 (Local Scope)首先，要先來解釋何謂區域作用域？簡單來說，區域作用域是相對於全域作用域的概念，只要不是在全域的範圍內的，都是屬於區域作用域，像是 function 函式、if 判斷式、for 和 else 的迴圈內的範圍，都是屬於區域作用域，而 JavaScript 的區域作用域又可分為函式作用域與區塊作用域。\n函式作用域 (Function Scope)函式作用域的範圍是在函式之內。\nfunction tellMyFavoriteSingerLately() &#123;let myFavoriteSingerLately = &#x27;Bruno Major&#x27;;console.log(&#x27;在函式作用域內的字串&#x27;, myFavoriteSingerLately); // 顯示 &#x27;Bruno Major&#x27;&#125;tellMyFavoriteSingerLately();console.log(&#x27;在函式作用域外的字串&#x27;, myFavoriteSingerLately); // 顯示 myFavoriteSingerLately is not defined.\n\n為何函式外的 console.log 會印出 not defined 呢？因為 myFavoriteSingerLately 這個變數在函式內被宣告後，它的作用域僅限於函式內，在函式外的地方就讀取不到這個變數。\n備註undefined 與 is not defined 是不同的，not defined 所指的是這個變數在這個區域是不存在的，根本讀取不到；undefined 則是指出在記憶體中有這一筆變數資料，只是尚未被賦予值。\n區塊作用域 (Block Scope)區塊作用域的範圍是在大括號 { } 之內。\n&#123;   let myFavoriteSingerLately = &#x27;Bruno Major&#x27;;&#125;console.log(myFavoriteSingerLately);  // 顯示 myFavoriteSingerLately is not defined.\n\n為什麼在大括號外的 console.log 會印出 not defined 呢？因為 myFavoriteSingerLately 這個變數在大括號內被宣告後，它的作用域僅限於大括號內，在大括號以外的地方就讀取不到這個變數。\n透過以 let 宣告變數在函式作用域與區塊作用域的例子，解釋了這兩個作用域的涵蓋範圍。在理解了這兩種作用域的範圍後，將在下一篇更進一步探討，var 和 let 的差異。\n","categories":["JavaScript","變數","作用域"],"tags":["JavaScript"]},{"title":"同層選取器？同層相鄰選取器？","url":"/2021/12/15/%E5%90%8C%E5%B1%A4%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%9F%E5%90%8C%E5%B1%A4%E7%9B%B8%E9%84%B0%E9%81%B8%E5%8F%96%E5%99%A8%EF%BC%9F/","content":"本篇短文主要是解釋「同層選取器(General Sibling Combinator)」與「同層相鄰選取器(Adjacent Sibling Combinator)」兩者的使用時機，再以實例比較兩者之間的差異。\n\n\n\n\n同層選取器 A ~ B假設要將 h1 標籤以下的 p 段落全部統一改為綠色字設定時，可使用同層選取器，可觀察到除了 h1 標籤仍為瀏覽器設定的字色以外，其以下的 p 段落全都被改為綠色字。\n\n\nh1 ~ p &#123;    color: green;&#125;\n\n&lt;h1&gt;瀏覽器預設字&lt;/h1&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;綠色字&lt;/p&gt;\n\n\n\n\n\n\n\n同層相鄰選取器 A + B假設只要將 h1 標籤以下的第一個 p 段落改為綠色字設定，其餘都不更動，可使用同層相鄰選取器，可觀察到只有 h1 標籤底下的第一個 p 段落字色為綠色，其餘的 p 段落仍保持原始瀏覽器設定的字色。\nh1 + p &#123;    color: green;&#125;\n\n&lt;h1&gt;瀏覽器預設字&lt;/h1&gt;&lt;p&gt;綠色字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;&lt;p&gt;瀏覽器預設字&lt;/p&gt;\n\n\n","categories":["CSS","選取器"],"tags":["CSS"]},{"title":"圖與文字同時可被搜尋到的技巧：以 h1 包覆 logo","url":"/2021/12/16/%E5%9C%96%E8%88%87%E6%96%87%E5%AD%97%E5%90%8C%E6%99%82%E5%8F%AF%E8%A2%AB%E6%90%9C%E5%B0%8B%E5%88%B0%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9A%E4%BB%A5%20h1%20%E5%8C%85%E8%A6%86%20logo/","content":"當在撰寫網頁時，如果想用 h1 標籤來包覆 logo 圖片，HTML 結構會是：\n&lt;h1&gt;    &lt;a href=&quot;＃&quot;&gt;&lt;img src=&quot;&quot;&gt;Karen&#x27;s Coding Notes&lt;/a&gt;&lt;/h1&gt;\n\n而在 CSS 則可以考慮選用 background-image 來置入 logo 圖片：\nh1 a &#123;  background-image: url(&#x27;https://reurl.cc/mLX1AM&#x27;)  background-repeat: no-repeat;  width: 262px;  height: 262px;  text-decoration: none;  color: #888;  display: block;&#125;\n\n此時，在瀏覽器上會顯示 logo 圖案，且在圖片之上也會顯示 a 標籤內的文字 Karen’s Coding Notes：\n到這裡，問題出現了，既然會用 h1 來包覆 logo 圖示，是代表 logo 被認定為這一頁的重要資訊，因為在網頁 SEO 的規則中，h1 意味著主要標題，一個網頁中也只能有一個。\n若 h1 是重要資訊，而爬蟲程式卻讀不到標籤內有文字，將會判定不符合 SEO 規定，因此內容不可空白。\n因此我們的目標是：\n\n在網頁架構中同時有 logo 圖示與字\n實際在頁面上又只顯示圖示而不要看見字\n\n由於 h1 本身就是一個區塊元素，那麼便可以考慮將文字推出區塊元素的原理，來進行文字的挪移。\n做法：\n\n用 text-indent: 101% 將文字推出 h1 之外\n用 overflow: hidden 將溢出區塊的部分都隱藏起來\n用 white-space: nowrap 強制這一串文字不換行\n\nh1 a &#123;  background-image: url(&#x27;https://reurl.cc/mLX1AM&#x27;);  background-repeat: no-repeat;  width: 262px;  height: 262px;  text-decoration: none;  color: #888;  display: block;  /*  將文字推出 &lt;h1&gt;  */  text-indent: 101%;  overflow: hidden;  white-space: nowrap;&#125;","categories":["CSS","背景","logo"],"tags":["CSS"]},{"title":"強制轉型 (1) 布林值篇","url":"/2021/12/16/%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B%E8%88%87%E8%BD%89%E6%8F%9B%E5%9E%8B%E5%88%A5%E7%9A%84%E8%A6%8F%E5%89%87-%E5%B8%83%E6%9E%97%E5%80%BC%E7%AF%87/","content":"JS 的強制轉型要開始探討 JavaScript 的強制轉型（coercion），也一樣是在談資料型別間如何轉換的問題。但因為不太可能記起所有的轉型變化，只能盡可能地去理解轉型的規則了。\n強制轉型的三大規則：\n\n強制轉型有分顯性轉型(explicit coercion)及隱性轉型(implicit coercion)。\n強制轉型將轉出：布林值、字串、數字。\n原始型別和物件型別這兩種值的轉換邏輯會不大一樣。(但目前只會先著重在紀錄原始型別的強制轉型)\n\n強制轉型的顯性與隱性轉型顯性轉型 透過手動的方式，以函式的方法轉換值的型別。隱性轉型 由 JS 主動來幫你轉。\n但總之，不管是人工透過函式或直接由 JS 幫你轉，最終也只會轉出布林值、字串、數字這三種型別。\n而在進入正題前，要先說明，本系列文章主要是參考 JavaScript type coercion explained 這篇文章分類的方式，再依我自己認為由簡單到複雜的程度，分別由布林值、字串、數字的順序來解釋強制轉型及其規則。\n布林值的顯性轉型如前言所述，顯性轉型是必須以手動方式透過函式的方法來進行型別的轉換，因此就以 Boolean(); 來舉例，不論是任何型別的值丟進函式 Boolean()，都會轉出布林值的結果。\n\n屬於 falsy 值的，透過函式則會轉出 false，\n屬於 truthy值的，在 Boolean() 也會轉出 true。\n\n// 轉出結果為 false 的組別console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false console.log(Boolean(-0)); //false console.log(Boolean(+0)); //false console.log(Boolean(NaN)); //false console.log(Boolean(&quot;&quot;)); //false // 轉出結果為 true 的組別 console.log(Boolean(&quot; &quot;)); //true console.log(Boolean(&quot;0&quot;)); //true console.log(Boolean(&quot;1&quot;)); //true console.log(Boolean(1)); // true console.log(Boolean(&quot;hello&quot;)); //true console.log(Boolean(&#123;&#125;)); //true console.log(Boolean([])); //true \n\n至於 truthy值與 falsy 值到底怎麼分，可參閱下表的整理：\n\n\n▲ Truthy、Falsy 值列表 (原始資料來源為深入理解 TypeScript ，再另將表格整理後製表。)\n\n\n\n布林值的隱性轉型根據前述，隱性轉型就是透過 JS 自動幫忙轉型。而 if 判斷式的原理，就是當 ( ) 內的值為 true 的時候，就會執行 { } 內的動作。\nif(true) &#123;   console.log(&#x27;因為是 true 才回傳這一行字&#x27;);&#125;\n\n因此這邊以 if 判斷式舉例，且也可以從回傳的印出結果，證實 if 判斷式在 ( ) 內，確實也能把非布林值的值進行轉換。\n// 以字串為例：if(&quot;a string&quot;)&#123;    console.log(&#x27;顯示這段話的時候，就是字串 &quot;a string&quot; 被轉為 true 了&#x27;);  //顯示&#125; else &#123;   console.log(&#x27;只有在 &quot;a string&quot; 被判定為 false 的時候，才會顯示這段話&#x27;); &#125; // 以數字為例：if(365)&#123;    console.log(&#x27;顯示這段話的時候，就是數字365 被轉為 true 了&#x27;);  //顯示&#125; else &#123;    console.log(&#x27;只有在數字365 被判定為 false 的時候，才會顯示這段話&#x27;); &#125;// 以 NaN 為例：if(NaN)&#123;    console.log(&#x27;顯示這段話的時候，就是 NaN 被轉為 true 了&#x27;);  //顯示&#125; else &#123;    console.log(&#x27;只有在 NaN 被判定為 false 的時候，才會顯示這段話&#x27;); &#125;\n\n備註 除了在 if 判斷式，邏輯運算子也會進行隱性轉型。\n","categories":["JavaScript","資料型別","原始型別","強制轉型"],"tags":["JavaScript"]},{"title":"強制轉型 (3) 數字型別與轉型規則篇","url":"/2021/12/16/%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B%E8%88%87%E8%BD%89%E6%8F%9B%E5%9E%8B%E5%88%A5%E7%9A%84%E8%A6%8F%E5%89%87-%E6%95%B8%E5%AD%97%E5%9E%8B%E5%88%A5%E7%AF%87/","content":"繼強制轉型的布林值、字串篇之後，本篇主要在歸納數字型別的強制轉型，並找出隱性轉型背後的原理。\n數字型別的顯性與隱性轉型強制轉型的三大規則：\n\n強制轉型有分顯性轉型(explicit coercion)及隱性轉型(implicit coercion)。\n強制轉型將轉出：布林值、字串、數字。\n原始型別和物件型別這兩種值的轉換邏輯會不大一樣。(但目前只會先著重在紀錄原始型別的強制轉型)\n\n數字的顯性轉型數字的顯性轉型一樣是透過函式，這邊將透過 Number() 為例說明，而根據印出的結果觀察到：\n\n透過 Number() 能轉為數字的，就會回傳數字\n透過 Number() 無法轉為數字的，會轉出 NaN（像是 undefined ）\n在運算過程當中，布林值 true 被 Number() 轉為數字 1、false 為數字 0\nnull、空字串將會被 Number() 轉為 數字 0\n\nlet a = &#x27;666666&#x27;; let b = &#x27;seven&#x27; let c = true; let d = false; let e = null; let f = undefined; let g = &quot;&quot;; console.log(Number(a), typeof Number(a)); // 回傳 666666 &#x27;number&#x27; console.log(Number(b), typeof Number(b)); // 回傳 NaN &#x27;number&#x27; console.log(Number(c), typeof Number(c)); // 回傳 1 &#x27;number&#x27; console.log(Number(d), typeof Number(d)); // 回傳 0 &#x27;number&#x27; console.log(Number(e), typeof Number(e)); // 回傳 0 &#x27;number&#x27; console.log(Number(f), typeof Number(f)); // 回傳 NaN &#x27;number&#x27; console.log(Number(g), typeof Number(g)); // 回傳 0 &#x27;number&#x27;\n\n備註 parseInt() 能將數字的字串取整數。\n數字的隱性轉型有運算子的時候，隱性轉型將自動把值轉換為數字型別進行運算，若無法轉為數字型別的，則會轉為字串。\n(一) 算術運算子算術運算子：加法let a = 3 + true //4 &#x27;number&#x27; let b = true + false //1 &#x27;number&#x27; let c = null + true; //1 &#x27;number&#x27; let d = null + 666; //666 &#x27;number&#x27; let e = undefined + 3; //NaN &#x27;number&#x27; // 無法轉換為數字的 undefined：console.log(undefined + null) // 回傳 NaN (number)\n\n備註 當 ( + ) 遇到字串就不會轉為數字型別！\n算術運算子：減法let a = 3 - true //2 &#x27;number&#x27; let b = true - false //1 &#x27;number&#x27; let c = null - true; //-1 &#x27;number&#x27; let d = null - 666; //-666 &#x27;number&#x27; let e = undefined - 3; //NaN &#x27;number&#x27;\n\n算術運算子：乘、除法let a = 3 * &quot;6&quot;; // 18 &#x27;number&#x27; let b = true * &quot;3&quot;;// 3 &#x27;number&#x27; let c = undefined * 3; // NaN &#x27;number&#x27; let d = undefined * &quot;3&quot;; // NaN &#x27;number&#x27; let e = undefined * true; // NaN &#x27;number&#x27; let f = null * 666; // 0 &#x27;number&#x27; let g = null * &quot;666&quot;; // 0 &#x27;number&#x27; let h = null * true; // 0 &#x27;number&#x27;\n\n註1：字串遇到乘法、除法都會轉為數字型別註2：任何值與 undefined 相乘、相除都是 NaN註3：任何值與 null 相乘、相除都是 0\n(二) 比較運算子在算術運算子整理到一段落後，接著是探討比較運算子 == 和 != 在強制轉型中的背後原理。\n為什麼是這兩個呢？因為首先需要知道：\n\n== 和 !=：著重在「值」的比較，因為不比較型別，所以可允許強制轉型發生作用。\n=== 及 !==：不允許強制轉型的發生，若不希望程式碼被強制轉型，請記得要使用 === 或 !==。\n\n\n\n\n\n\n\n符號\n特性\n\n\n\n一般相等\n==\n轉為相同型別，再比較兩者的值\n\n\n嚴格相等\n===\n先看型別，再看值\n\n\n不等於\n!=\n比較兩者的值，但不比較型別\n\n\n嚴格不等於\n!==\n先看型別，再看值\n\n\n備註 嚴格相等 === 與嚴格不等於 !== 皆不允許自動轉型！\n比較運算子：＝＝範例 1 == 的運算過程，為了要比較「值」，會執行隱性轉型的動作，可以視為是字串 ‘666’ 被隱性轉型為 Number(‘666’)，故得到運算結果為 true。而 === 會先比較型別、再比較「值」，因此 === 只要先發現型別不同，就回傳 false，所以不希望程式碼被 JS 隱性轉型的時候，就應該使用 ===。\n// 範例1 console.log(666 == &#x27;666&#x27;); // true console.log(666 === &#x27;666&#x27;); // false\n\n範例 2 true 跟 ‘1’ 都經歷了隱性轉型的過程，第一行程式碼可以視為是 Number(true) == Number(‘1’)，故得到 true。\n// 範例2console.log(true == &#x27;1&#x27;); //true console.log(true === &#x27;1&#x27;); //false\n\n範例 3 上述兩個範例都是能被轉換為數字型別的，但是，當遇到非字串也非布林值的狀況，結果會是如何？\n這邊在 == 的運算中，可以視 null 為 String(null)，所以是 ‘null’ 不等於空字串，故得到 false。原因是隱性轉型是由 JS 來幫你決定轉哪一種，運算子的運算過程中，會先自動轉為數字型別，若不能轉為數字的，會改而轉字串，再比較值。\n// 範例3console.log(null == &#x27;&#x27;); //false console.log(null === &#x27;&#x27;); //false\n\n\n\n比較運算子：！＝範例 1 為何 666 不等於 ‘666’ 是 true，但 666 不等於 ‘666’ 又變成 false?很關鍵的一點就在於，比較運算子 != 也是會忽略型別，並允許字串被轉換為數字，再比較「值」；相反地，!== 則是會優先比較型別，再看值。\n範例 2 遇到兩者都非數字的情況下，運算過程也可被視為是 Number(true) 跟 Number(‘1’) 的運算，得到 false 的結果。\n// 範例1 console.log(666 != &#x27;666&#x27;); // false console.log(666 !== &#x27;666&#x27;); // true // 範例2 console.log(true != &#x27;1&#x27;); // false console.log(true !== &#x27;1&#x27;); // true\n\n\n總結最後歸納出四個重點：\n\n強制轉型有分為顯性轉型與隱性轉型，不管哪一種轉型，也只會轉出布林值、字串或數字其中一種。\n顯性轉型都是以手動用函式的方法將值轉換為自己指定要的型別。\n隱性轉型是由 JS 來幫你決定轉哪一種，當有運算子的時候，會優先轉為數字型別；遇到無法轉為數字的，改而轉成字串，再比較值。\n承第 3 點，加法運算子是較為特殊的一種，若遇到有字串，則優先轉字串再比較值。\n\n\n\n參考資料\nMDN — Equality comparisons and sameness\nMDN — 算術運算子\n重新認識 JavaScript: Day 07 「比較」與自動轉型的規則\n何謂強制轉型、以及如何作到轉換型別？\nType Coercion in JavaScript\nDay11 — 寬鬆相等 VS. 嚴格相等\n[27] 強制轉型 — 寬鬆相等 ( == ) vs. 嚴格相等 ( === )\n[27–1] 強制轉型 — 番外篇 （ 運算子預設的規定 ex: ==、+ ）\n\n","categories":["JavaScript","資料型別","原始型別","強制轉型","比較運算子"],"tags":["JavaScript"]},{"title":"活用 CSS backgrounds 做滿版背景 (上)","url":"/2021/12/16/%E6%B4%BB%E7%94%A8%20CSS%20backgrounds%20%E5%81%9A%E6%BB%BF%E7%89%88%E8%83%8C%E6%99%AF%20(%E4%B8%8A)/","content":"設計網頁版型的時候，經常會用一張滿版圖片來作為主視覺，以 CSS backgrounds 加入背景圖的方式來進行。\n最常用來做滿版主視覺的屬性有：\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-position\nbackground-size\nbackground\n\n使用 background-repeat 節省背景圖檔容量首先，就先來談談，background-image, background-repeat, 與  background-color 的搭配應用，以及該如何節省背景圖檔的容量！\n在製作素面背景的時候，假設有一張背景圖的大小為寬 1200 px、高 675 px，當這張圖整張上傳的時候，檔案大小為 154KB。乍看一張背景圖檔不過是154 KB 不是特別有感，但如果你的網頁有300人次瀏覽，那麼就是46MB的流量了，長期累積下來也相當驚人。\n\n\n當遇到這樣的情況，建議可以先在 PS 用切片工具把背景圖切一小段下來，經過切圖之後的背景圖檔，只剩下一小塊約 21KB 左右的檔案大小，接著再使用這張裁切後的小圖，就同樣能達到原先直接用 background-image 置入一整張大圖的效果，節省流量！\n\n\n不過，當容器內有文字，版面自動向下擴充時，由於背景的顏色有漸層，會產生畫面中顏色不連續的情形。\n\n\n不過，當容器內有文字，版面自動向下擴充時，由於背景的顏色有漸層，會產生畫面中顏色不連續的情形。所以這一張裁切後的小圖，還需搭配 background-repeat: repeat-x，以 X 軸重複顯示的方式來填滿視窗的背景，另外同時也要記得吸取不連續段落之間最下方的顏色，作為 background-color 背景色，就能解決顏色不連貫的問題了！\n.box&#123;    width: 1200px;    background-image: url(&#x27;./img/bg2.png&#x27;);    background-repeat: repeat-x;    background-color: #3fa9f5;&#125;\n\n總結：善用 background-repeat 節省檔案大小用背景圖進行版面設計時，必須考量到網頁效率問題，畢竟一張大的圖檔是很吃容量的，能預先考慮到背景圖該如何裁切能使其容量最精簡，對使用者來說，瀏覽網頁效率也能提高：background-repeat: no-repeat; 大張圖檔，只顯示一次background-repeat: repeat-x; 以X軸為基準重複background-repeat: repeat-y; 以Y軸為基準重複\n交互運用 background-color 與 background-image當高度沒有寫固定，背景會隨容器中的內容增加而自動向下延伸，導致背景顏色出現不連貫時，可以填入 background-color 作為容器中背景圖的延伸，以求整體版面一致性。\n","categories":["CSS","背景"],"tags":["CSS"]},{"title":"物件取值：用方括號取值","url":"/2021/12/16/%E7%89%A9%E4%BB%B6%E5%8F%96%E5%80%BC%EF%BC%9A%E7%94%A8%E6%96%B9%E6%8B%AC%E8%99%9F%E5%8F%96%E5%80%BC/","content":"用方括號取值 (Bracket notation)obj[value]透過方括號的物件取值，value 可以視為是一個字串(透過單或雙引號包裹的一個字串、數字或布林)，而我們可以透過此一特性，在物件中代入一個字串或一個變數。\n在 [ ] 帶入字串console.log(pencilCase[&quot;brand&quot;])// 回傳 &quot;Kokuyo&quot; console.log(pencilCase[&quot;year&quot;])// 回傳 2020 console.log(pencilCase[&quot;contents&quot;]) // 回傳 [&#x27;ruler&#x27;, &#x27;pencil&#x27;, &#x27;pen&#x27;, &#x27;eraser&#x27;] console.log(pencilCase[&quot;01_price&quot;]) // 回傳 990\n\n在 [ ] 帶入變數在前述例子中，用方括號取值的時候，都會在屬性外面再加一組單引號 ‘ ‘ 或雙引號 “ “，因為這些屬性都是屬於原始型別資料，因此需要透過單引號或雙引號來選取這些屬性。\n為何要在物件中代入變數？當需要抓取物件內某一個屬性的值，再做其他運用，這時候可透過宣告一個新的變數，另外單獨儲存這一個值。\nlet myPencilCase = &#123;     &quot;price&quot;: 300,     &quot;contents&quot;: [ &quot;scissor&quot;, &quot;eraser&quot;, &quot;fountain pen&quot;] &#125; let stationary = &quot;contents&quot;; //在物件中代入變數console.log(myPencilCase[&quot;contents&quot;]); //回傳 [ &quot;scissor&quot;, &quot;eraser&quot;, &quot;fountain pen&quot;](3) console.log(myPencilCase[stationary]); //回傳 [ &quot;scissor&quot;, &quot;eraser&quot;, &quot;fountain pen&quot;](3) //代表已成功在物件中代入變數\n\n當透過方括號的物件取值代入變數的時候，也就等同於把 “contents” 這個字串代入到方括號內，因此兩種方法都可取得一樣的值。\n註 用點取值的方式無法取到變數，只能直接取到屬性。\n總結\n物件取值有兩種方式：用點( . ) 或用方括號 [ ] 取值。\n用點取值只能取到屬性名稱開頭為：\n\n\n英文字母\n漢字\n下底線 ( _ )\n錢字符號 ( $ )\n\n\n用點取值取不到的屬性，可以用方括號 [ ] 取值。\n當有需要從物件中抓取一筆值另作他用，可透過方括號 [ ] 取值代入變數來儲存這筆值。\n\n表格整理\n\n\n\n\n\n參考資料\n從零開始的學習 JS 生活-第五日之陣列與物件\nMDN — JavaScript 物件基礎概念\nMDN — 物件的使用\nJavaScript 核心篇 學習筆記: Chap.30 — 物件取值，新增與刪除\n\n","categories":["JavaScript","物件型別"],"tags":["JavaScript"]},{"title":"物件取值：用點取值","url":"/2021/12/16/%E7%89%A9%E4%BB%B6%E5%8F%96%E5%80%BC%EF%BC%9A%E7%94%A8%E9%BB%9E%E5%8F%96%E5%80%BC/","content":"物件取值是在做什麼？物件裡面可以裝載很多資料，妥善的規劃程式碼結構，並懂得運用這些資料，可以讓程式碼更為精簡。當需要從物件取用這些資料的時候，就要透過物件取值，其中物件取值有兩種方法，一種是直接透過 . 來取值，另外一種則是以 [ ] 來取值。\n用點取值 (Dot notation)直接取到物件內的某一個屬性的值。\nconsole.log(pencilCase.brand)// 回傳 &quot;Kokuyo&quot;console.log(pencilCase.year)// 回傳 2020 console.log(pencilCase.contents) // 回傳 [&#x27;ruler&#x27;, &#x27;pencil&#x27;, &#x27;pen&#x27;, &#x27;eraser&#x27;] console.log(pencilCase.01_price) // 回傳 undefined\n\n01_price 這個屬性，用點取值抓不到資料，因此要改用方括號取值才行。\n可以直接用點取值的屬性當屬性名稱開頭為以下項目：\n\n英文字母\n漢字\n下底線 ( _ )\n錢字符號 ( $ )\n\n除此之外的都屬特殊字元，用方括號才取得到值。\n","categories":["JavaScript","物件型別"],"tags":["JavaScript"]},{"title":"認識 undefined 與 null 的型別","url":"/2021/12/16/%E8%AA%8D%E8%AD%98%20undefined%20%E8%88%87%20null%20%E7%9A%84%E5%9E%8B%E5%88%A5/","content":"在探討這三者的差異前，必須先知道在 JavaScript 裡面有分原始型別及物件型別 (見下圖) 。\n七種原始型別 ( Primitive Data Type )：\n字串 (string type)\n布林值 (Boolean type)\n數字 (number type)\n整數數值 (BigInt type)\nundefined (undefined type)\nnull (null type)\nsymbol (symbol type)\n\n隸屬原始型別：undefined 與 null上面特別列出了type，不是因為吃飽特閒，而是因為刻意要強調原始資料型別 (type)這件事。\n更仔細去看 MDN 文件的話，所有的原始資料型別都有原始值 (primitive value)，而這是不可被更改的值。\n例如：布林值有兩種原始值，true 及 false，而這兩種原始值不可更動（但如果是變數的值，就可以更動）。\n因此根據上面的資料來看，undefined 與 null 都是屬於原始資料型別！\n比較 undefined 與 nullundefined 作為值假如宣告一個變數 foo1，但不賦予值，變數的回傳是 undefined：\nlet foo1;console.log(foo1)// undefined\nnull 作為值但假如宣告一個變數 foo2，並賦予值為 null，變數的值就是 null：\nlet foo2 = null;console.log(foo2); // null\n\n也就是說，這兩者的差異在於「有沒有對變數賦予值」吧，哎唷，原來事情就是這麼簡單而已啊。\n不不不…!!!!!! 不是的。\n記得剛剛為什麼要特別去強調資料「型別」的type這件事嗎？\n請注意，型別和值是兩回事喔，如果剛剛的 console.log 顯示的是變數的值，那麼接下來用 typeof 來觀察，我們會發現：\n\nundefined 的值，型別為 undefined\nnull 的值，型別為 object\n\nundefined 作為值的型別假如用 typeof 查詢 undefined value，回傳：undefined\nconsole.log(typeof undefined) //undefined\n\nnull 作為值的型別但同樣用 typeof 查詢 null value，回傳：object\nconsole.log(typeof null) //object\n\n\n\n表格一：值與型別的回顧\n\n\n\n值 (value)\n型別 (typeof value)\n\n\n\n變數：未賦值\nundefined\nundefined\n\n\n變數：賦予「空值」\nnull\nobject\n\n\n\n\n\n以比較運算子驗證 undefined 與 null 的型別假如 undefined 的型別是 undefined，那 null 的型別怎麼會是 object？相傳 null 的型別為 object 是 javascript 從發明之初就有的 bug，若去更動會產生很多問題，而我們也可以透過 JavaScript 規範查詢，看看要如何理解這個 bug。\nnull value 的意義null value primitive value that represents the intentional absence of any object valuenull 是有意的要去指出一個物件的值是不存在的狀態。\nundefined value 的意義undefined value primitive value used when a variable has not been assigned a valueundefined 代表一個變數未被賦予值、尚未被初始化的狀態，所以每個變數在尚未被初始化前一定都有個 undefined 值。\n驗證 null 與 undefined 的型別：範例一如果是兩個不同型別的值，會被 !== 判定為不相等。\n\nundefined 的型別是 undefined\nnull 的型別是 object\n\n兩者型別不同，比較結果為 true。\nconsole.log(null !== undefined) // true\n\n範例二\nundefined 是變數在宣告的時候沒有賦予值\nnull 是賦予變數一個「空值」\n\n由於 == 會自動轉換成相同型別之後再進行比較，在相同型別底下，推測因 null 與 undefined 都是 falsy 值，故兩者會是相等的，結果是 true。\nconsole.log(null == undefined) // true\n\n註1：falsy 值並不等於 false，但本文並不會解釋 falsy 值，可參閱：Truthy 與 Falsy。註2：這邊特別注意的是，null、undefined 並不等於 0 喔！\n範例三如果 null 的資料型別是 object、undefined 的型別是 undefined，兩者型別不相等，所以比較結果為 false。\nconsole.log(null === undefine) // false\n\n\n\n\n表格二：比較運算子\n\n\n\n符號\n特性\n\n\n\n嚴格不等於\n!==\n兩個不同的值，被視為不相等\n\n\n一般相等\n==\n轉為相同型別，再比較兩者的值\n\n\n嚴格相等\n===\n先看型別，再看值\n\n\n註1 一般相等(equality operator)：會自動被轉型別。註2 嚴格相等(identity operator) ：被比較的兩個值都不會被自動轉換型別，若值為不同型別，被視為不相等。\n\n\n\nundefined 等於 not defined 嗎？最後，還要來比較一下 undefined 與 not defined，這兩者也是常常會很令人困惑的。但我先說，答案很肯定是：NO。\n既然現在已經知道，undefined 為 JS 七種資料型別之一，當宣告一個變數，但未賦予值，它預設的值就會是 undefined，這大概於類似電腦告訴你：「ㄟ，我知道是有這個人啦，但齁，我不知道是從哪裡來的啦，歹勢！」\n那什麼時候會出現 not defined 呢？當看到回傳 xxx is not defined 的時候，是代表某一個變數根本都還不存在，也就是說變數連被宣告的這個動作都還沒有，類似於電腦告訴你：「ㄟ，沒這個人啦，搞不好齁，他連投胎都還沒去！」\n參考資料\n嚴格不等於\n相等比較\n你懂 JavaScript 嗎？#4 型別（Types）\nAn Essential Guide to JavaScript null\nhttps://tc39.es/ecma262/#sec-null-value\nEverything about null in JavaScript\nTruthy 與 Falsy\n初學者第一坑 — typeof 運算子, 詳解 undefined\n\n","categories":["JavaScript","資料型別","原始型別","比較運算子"],"tags":["JavaScript"]},{"title":"認識 switch 的用法","url":"/2021/12/16/%E8%AA%8D%E8%AD%98-switch-%E7%9A%84%E7%94%A8%E6%B3%95/","content":"switch 的基本結構主要由 switch, case, break 和 default 組成。\nswitch 的 (  )switch 的 ( ) 內，主要是一個變數，而變數的值可能是字串、布林值、數字、null、undefined，而這個變數將和 case 後面的值進行比對。\ncasecase 後面接的是判斷條件，角色和 if 判斷式中的 if 相似。\ndefaultdefault 的角色跟 if 判斷式中的 else 相似。break 的功能在於中斷程式碼，所以沒有 break，程式碼仍可執行，只是會把所有的 case 都跑完，得到的結果可能不精準，如何運用要看情況。\nswitch 的寫法const myCar = &#x27;Porsche&#x27;; switch(myCar) &#123; case &#x27;Volvo&#x27;: console.log(&#x27;我開 Volvo&#x27;); break; case &#x27;Benz&#x27;: console.log(&#x27;我開 Benz&#x27;); break; case &#x27;VolksWagen&#x27;: console.log(&#x27;我開 VolksWagen&#x27;); break; case &#x27;Porsche&#x27;: console.log(&#x27;我開 Porsche&#x27;); break; default: console.log(&#x27;我沒車！&#x27;); break; &#125; // 印出 &#x27;我開 Porsche&#x27;\n\n","categories":["JavaScript","流程判斷"],"tags":["JavaScript"]},{"title":"邏輯運算子 (非布林值運算)","url":"/2021/12/16/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90(%E9%9D%9E%E5%B8%83%E6%9E%97%E5%80%BC%E9%81%8B%E7%AE%97)/","content":"邏輯運算子轉換布林值首先還是先回顧一下，依照最基礎定義，&amp;&amp; 和 || 在運算「純」布林值的時候，會回傳 true、false，最基礎可發展出這八種變化：\nconsole.log(true &amp;&amp; true) // 回傳 trueconsole.log(true &amp;&amp; false) // 回傳 falseconsole.log(false &amp;&amp; true) // 回傳 falseconsole.log(false &amp;&amp; false) // 回傳 falseconsole.log(true || true) // 回傳 trueconsole.log(true || false) // 回傳 trueconsole.log(false || true) // 回傳 trueconsole.log(false || false) // 回傳 false\n\n邏輯運算子轉換非布林值邏輯運算子也同時能用於運算「非布林值」，並且會回傳真值、虛值，而這些「非布林值」當然就包括原始型別與物件型別：\n真值與虛值題目篇// 數字console.log(0 &amp;&amp; 1)//回傳值為 0console.log(0 || 1)//回傳值為 1// 字串console.log(&#x27;goodbye&#x27; &amp;&amp; &#x27;hello&#x27;) //回傳 &#x27;hello&#x27;console.log(&#x27;goodbye&#x27; || &#x27;hello&#x27;) //回傳 &#x27;goodbye&#x27;// null 及 undefinedconsole.log(null &amp;&amp; undefined) // 回傳 nullconsole.log(null || undefined) // 回傳 undefined// 物件 及 陣列console.log(&#123;&#125; &amp;&amp; []) // 回傳 arrayconsole.log(&#123;&#125; || []) // 回傳 object\n\n如果你看完邏輯運算子轉換非布林值的過程後，也跟我一樣很想問，為什麼會這樣？那麼在這邊就應該先了解一下何謂真值與虛值了(上面8題詳解在下方)。\n真值與虛值列表大集合分辨真值、虛值與布林值的要點 ：\n\n布林值 true 和 false 是原始資料型別的其中一種。\ntruthy 不等於 true、falsy 也不等於 false，它們是不同的東西。\nfalsy 以外的都是 truthy\n\n\n\n▲ Truthy、Falsy 值列表 (原始資料來源為深入理解 TypeScript ，再另將表格整理後製表。)\n看完 truthy、falsy 之後，應該能比較好理解邏輯運算子是如何運算非布林值的了吧！那麼讓我們再一次回顧剛剛的 8 題：\n真值與虛值解答篇// 數字console.log(0 &amp;&amp; 1)//回傳值為 0，為 falsyconsole.log(0 || 1)//回傳值為 1，為 truthy// 字串console.log(&#x27;goodbye&#x27; &amp;&amp; &#x27;hello&#x27;) //回傳 &#x27;hello&#x27;，字串是 truthyconsole.log(&#x27;goodbye&#x27; || &#x27;hello&#x27;) //回傳 &#x27;goodbye&#x27;，字串是 truthy// null 及 undefinedconsole.log(null &amp;&amp; undefined) // 回傳 null，是 falsyconsole.log(null || undefined) // 回傳 undefined，是 falsy// 物件 及 陣列console.log(&#123;&#125; &amp;&amp; []) // 回傳 array，陣列是 truthyconsole.log(&#123;&#125; || []) // 回傳 object，物件是 truthy\n\n希望看到這邊，你已經更理解邏輯運算子的運算過程了。\n不過，你知道嗎？其實邏輯運算子也跟 CSS 的 class、ID 一樣，有權重之分哪！\n邏輯運算子的權重有關邏輯運算子的權重，可以參考這篇 MDN。根據 MDN 的資料來看，&amp;&amp; 的權重為 6 分、|| 的權重為 5 分，因此當遇到 &amp;&amp; 與 || 在同一個運算式的時候，就會先算 &amp;&amp; 再算 ||。\nconsole.log(null || NaN &amp;&amp; &quot;hello&quot; &amp;&amp; 666 || &quot;0&quot;)\n\n在這個例子當中，電腦會先運算 NaN &amp;&amp; “hello” &amp;&amp; 666 這一段，再處理其餘的部分，因此回傳結果為 “0”。\n你，答對了嗎？\n參考資料\n用邏輯判斷 ||(OR) 及 &amp;&amp;(AND) 來改寫 if (短路求值 Short-circuit evaluation)\n[JS基礎]如何使用邏輯運算子 &amp;&amp; 和 ||\n重新認識 JavaScript: Day 08 Boolean 的真假判斷\n深入理解 TypeScript\n第29天-Truthy和Falsy\nMDN — 邏輯運算子\nMDN — 運算子優先序\n\n","categories":["JavaScript","邏輯運算子"],"tags":["JavaScript"]},{"title":"邏輯運算子 (布林值運算)","url":"/2021/12/16/%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90(%E5%B8%83%E6%9E%97%E5%80%BC%E9%81%8B%E7%AE%97)/","content":"邏輯運算子簡介邏輯運算子的三種符號\n\n&amp;&amp; (and)：當所有用 &amp;&amp; 連接的條件都是 true，就回傳 true，否則回傳 false\n|| (or)：所有用 || 連接的條件，只要其中有一個是 true，就回傳 true\n! (not)：!true 會回傳 false，而 !false 會回傳 true\n\n短路求值 (short-circuit evaluation)根據 MDN 文件的定義\n\n邏輯運算子通常被用於布林值；使用於布林值時，它們會回傳布林型態的值。然而，&amp;&amp; 和 || 運算子實際上是回傳兩指定運算元之一，因此用於非布林型態值時，它可能會回傳一個非布林型態的值。\n而上述這段話大概又可以再拆解出下面這兩個問題：\n\n什麼叫做短路求值？\n布林值、真值、虛值到底怎麼分？\n\n何謂短路求值？根據 MDN 的解釋：Short-circuit evaluationAs logical expressions are evaluated left to right, they are tested for possible “short-circuit” evaluation using the following rules:false &amp;&amp; anything is short-circuit evaluated to false.true || anything is short-circuit evaluated to true.The rules of logic guarantee that these evaluations are always correct. Note that the anything part of the above expressions is not evaluated, so any side effects of doing so do not take effect.\n也就是說：\n\n邏輯運算子的運算順序是：由左至右。\n在 &amp;&amp; 的運算中，可求出為 false 的值。\n在 || 的運算中，可求出為 true 的值。\n\n&amp;&amp; 邏輯運算子的短路求值舉例說明：從 MDN 已經知道定義了。但假如有 2 個以上的布林值用 &amp;&amp; 運算呢？這樣看可能會更清楚。從以下四個印出的結果，可以想像，&amp;&amp; 的運算過程只要遇到 false 就跳出停止，同時得到 false。\nconsole.log(true &amp;&amp; true); //回傳 trueconsole.log(false &amp;&amp; true); //回傳 falseconsole.log(true &amp;&amp; false &amp;&amp; true); //回傳 falseconsole.log(true &amp;&amp; true &amp;&amp; false &amp;&amp; true); //回傳 false\n\n|| 邏輯運算子的短路求值在遇到都是 false 的情況下，|| 才回傳 false；反之，只要有一個 true 就會回傳 true。但假如有兩個以上的布林值用 || 運算呢？那結果又會如何？從以下印出的結果，一樣可以想像為，|| 的運算過程只要遇到 true 就跳出停止，同時得到 true 的結果。\nconsole.log(true || true); //回傳 trueconsole.log(false || false); //回傳 falseconsole.log(true || false); //回傳 trueconsole.log(false || true || false); //回傳 true (在第二個true跳出)console.log(false &amp;&amp; false &amp;&amp; true &amp;&amp; true); // true(在第三個true跳出)\n\n小結看到這邊，大概可以歸納出何謂「短路賦值」：\n\n邏輯運算子 &amp;&amp; 的運算過程:會是由左至右，回傳第一個是 falsy 的值。若皆為 truthy，則回傳最後一個值。\n\n邏輯運算子 || 的運算過程:會是由左至右，回傳第一個是 truthy 的值。若皆為 falsy，則回傳最後一個值。\n\n\n以上的部分，都是邏輯運算子的布林值運算，但如果要運算非布林值的時候，又該如何判斷 true 或 false?因此下一篇將著重解釋非布林型態的值，並會探討真值 truthy 及虛值 falsy。\n","categories":["JavaScript","邏輯運算子"],"tags":["JavaScript"]},{"title":"強制轉型 (2) 字串篇","url":"/2021/12/16/%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B%E8%88%87%E8%BD%89%E6%8F%9B%E5%9E%8B%E5%88%A5%E7%9A%84%E8%A6%8F%E5%89%87-%E5%AD%97%E4%B8%B2%E7%AF%87/","content":"字串的顯性與隱性轉型強制轉型的三大規則：\n\n強制轉型有分顯性轉型(explicit coercion)及隱性轉型(implicit coercion)。\n強制轉型將轉出：布林值、字串、數字。\n原始型別和物件型別這兩種值的轉換邏輯會不大一樣。(但目前只會先著重在紀錄原始型別的強制轉型)\n\n字串的顯性轉型\n字串的顯性轉型一樣是透過函式。\n透過回傳結果可觀察到 String() 將數字、布林值、null、undefined 轉為字串。\n\nlet a = 666666; let b = true; let c = false; let d = null; let e = undefined; console.log(String(a), typeof String(a)); // 回傳 666666 string console.log(String(b), typeof String(b)); // 回傳 true string console.log(String(c), typeof String(c)); // 回傳 false string console.log(String(d), typeof String(d)); // 回傳 null string console.log(String(e), typeof String(e)); // 回傳 undefined string console.log(d.toString()); //Uncaught TypeError: Cannot read properties of null (reading &#x27;toString&#x27;) console.log(e.toString()); //Uncaught TypeError: Cannot read properties of undefined (reading &#x27;toString&#x27;)\n\n備註String(value) 和 value.toString() 都是能強制轉型為字串的函式，但在 value.toString() 這個方法中，null 和 undefined 將無法轉為字串型別。\n字串的隱性轉型字串的隱性轉型，必要的條件是在算式中，至少其中一個值為字串，( + ) 運算子會觸發隱性轉型，以下組合都會轉出字串：\n\n字串 + 字串\n字串 + 數字\n字串 + 布林值\n字串 + undefined\n字串 + null\n字串 + NaN\n字串 + 數字 + null\n字串 + 物件\n字串 + 陣列\n\nlet a = &quot;3&quot; + &quot;3&quot;; let b = &quot;8&quot; + 3; let c = &quot;9&quot; + true; let d = undefined + &quot;3&quot;; let e = null + &quot;3&quot;; let f = NaN + &quot;aaa&quot;; let g = null + 111 + &quot;666&quot;; let h = &quot;here&quot; + &#123;&#125;; let i = &quot;here&quot; + []; console.log(a, typeof a); // 回傳 33 string console.log(b, typeof b); // 回傳 83 string console.log(c, typeof c); // 回傳 9true string console.log(d, typeof d); // 回傳 undefined3 string console.log(e, typeof e); // 回傳 null3 string console.log(f, typeof f); // 回傳 NaNaaa string console.log(g, typeof g); // 回傳 111666 string console.log(g, typeof h); // 回傳 here[object Object] string console.log(g, typeof i); // 回傳 here[object Object] string\n\n以上為布林值及字串的強制轉型，而下一篇將專注在整理數字的強制轉型，並比較多在討論比較運算子 == 寬鬆等於、!= 寬鬆不等於的隱性轉型過程。\n參考資料\nDay10 — 隱含的強制轉型\n[22] 強制轉型 — ToBoolean、Falsy、Truthy\nJavaScript type coercion explained\nMDN — Addition (+)\nJS 我轉型我又轉了打我阿笨蛋\n\n","categories":["JavaScript","資料型別","原始型別","強制轉型"],"tags":["JavaScript"]},{"title":"JS 中的傳值與傳址 (傳值篇)","url":"/2021/12/16/JS%20%E4%B8%AD%E7%9A%84%E5%82%B3%E5%80%BC%E8%88%87%E5%82%B3%E5%9D%80(%E5%82%B3%E5%80%BC%E7%AF%87)/","content":"理解傳值和傳址最重要的三大關鍵\n必須先能分清楚「值」有分物件型別、原始型別\n變數在賦予值的時候，電腦記憶體空間是如何運作的\n有沒有進行「重新賦予值」這個動作\n\n基本上掌握這三點，那麽這個問題大概就先理清了一大半。所以，在要回答這個問題之前，是不是應該先問，什麼是值？\n什麼是「值」(Value)？先前在分辨 null 與 undefined 的差異這篇文章內，已討論過何謂「值」。所謂的「值」，就是在變數裡存進去的一筆資料，而這資料又分為物件型別與原始型別，可參考以下示意圖。\n\n\n如何運用「值」？舉例來說，今天有一個人名叫 Karen，他說他目前最喜歡的歌手叫做 Bruno Major，這一筆資料的值是一個人名，型別是字串。於是，Karen 最喜歡的歌手是 Bruno Major 這一筆資料，就儲存在 karenFavoriteSinger 這個變數裡了：\nlet karenFavoriteSinger = &#x27;Bruno Major&#x27;;\n\n什麼是「傳值」？此時，又來了一個 Karen 的同學 Yang，Yang 說好巧啊，他最喜歡的歌手也是 Bruno Major！所以他們兩個都很喜歡同一個歌手，於是可以這樣寫：\nlet yangFavoriteSinger = karenFavoriteSinger; //傳值 console.log(yangFavoriteSinger); // 回傳 Bruno Major\n\n又過了幾天，Karen 突然在 Watermelon Music 聽到了一首超棒的歌，噢，結果他很興高采烈地跟 Yang 分享這件事，他對天空大聲高喊說，他發現突然已經沒那麼喜歡 Bruno Major 了，現在他最喜歡的歌手是 Robbie Williams，於是可以這樣寫：\nkarenFavoriteSinger = &#x27;Robbie Williams&#x27;;\n\n現在，讓我們再度回過頭檢視 karenFavoriteSinger 和 yangFavoriteSinger 這兩個變數吧！\nconsole.log(karenFavoriteSinger); //回傳 Robbie Williams console.log(yangFavoriteSinger); // 仍然回傳 Bruno Major\n\n所以「傳值」這件事，其實可以理解為，Karen 和 Yang 曾經有過共同喜歡的歌手，但後來雖然 Karen 變了，他喜歡的跟 Yang 不同了，但是，Yang 是個有主見的人，他並不需要跟著一起改變啊！\n然而，這個現象背後的原理是：當變數每一次被賦予一個新的值，電腦都會開一個記憶體來儲存這個值，並重新將變數指向這個記憶體。\n兩步驟拆解「傳值」：\n電腦「複製」一個完完全全相同的值\n電腦同時新開一個記憶體空間儲存這個值，並把變數 yangFavoriteSinger 指向到這個值過去，最後，值都是儲存在各自獨立的記憶體空間。\n\n既然傳值後，值都是儲存在各自獨立的記憶體空間，那麼當變數重新賦予一個新的值，自然也會再依循剛剛的兩個步驟再走一次。\n\n\n小結：傳值的兩個重點\n傳值所指的「值」都是屬於原始資料型別 (Primitive Type)。\n傳值有一個很關鍵的重點是「複製」，複製後在記憶體空間中，兩個變數的值都是獨立存在不同的記憶體之中，因此，就算其中一方突然改變心意，各自都還是獨立個體，並不互相影響。\n\n","categories":["JavaScript","變數與記憶體","資料型別","原始型別"],"tags":["JavaScript"]}]